<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>SITMUN Core Angular Library documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">SITMUN Core Angular Library documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content class">
                   <div class="content-data">











<ol class="breadcrumb">
  <li>Classes</li>
  <li>BaseLayerGroup</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/main/angular-library/projects/sitmun-plugin-core/src/lib/map/map.component.ts</code>
        </p>

            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>Base layer group</p>

            </p>




            <section>
    <h3 id="index">Index</h3>
    <table class="table table-sm table-bordered index-table">
        <tbody>
                <tr>
                    <td class="col-md-4">
                        <h6><b>Properties</b></h6>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <ul class="index-list">
                            <li>
                                <a href="#id">id</a>
                            </li>
                            <li>
                                <a href="#memberIds">memberIds</a>
                            </li>
                            <li>
                                <a href="#memberPositions">memberPositions</a>
                            </li>
                            <li>
                                <a href="#name">name</a>
                            </li>
                        </ul>
                    </td>
                </tr>






        </tbody>
    </table>
</section>


            <section>
    
        <h3 id="inputs">
            Properties
        </h3>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="id"></a>
                        <span class="name">
                            <b>
                            id</b>
                            <a href="#id"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                        </td>
                    </tr>
                        <tr>
                            <td class="col-md-4">
                                    <div class="io-line">Defined in <a href="" data-line="71" class="link-to-prism">src/main/angular-library/projects/sitmun-plugin-core/src/lib/map/map.component.ts:71</a></div>
                            </td>
                        </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>BaseLayer Group Id</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="memberIds"></a>
                        <span class="name">
                            <b>
                            memberIds</b>
                            <a href="#memberIds"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Type : </i>    <code>number[]</code>

                        </td>
                    </tr>
                        <tr>
                            <td class="col-md-4">
                                    <div class="io-line">Defined in <a href="" data-line="77" class="link-to-prism">src/main/angular-library/projects/sitmun-plugin-core/src/lib/map/map.component.ts:77</a></div>
                            </td>
                        </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>Member layer ids</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="memberPositions"></a>
                        <span class="name">
                            <b>
                            memberPositions</b>
                            <a href="#memberPositions"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Type : </i>    <code>number[]</code>

                        </td>
                    </tr>
                        <tr>
                            <td class="col-md-4">
                                    <div class="io-line">Defined in <a href="" data-line="75" class="link-to-prism">src/main/angular-library/projects/sitmun-plugin-core/src/lib/map/map.component.ts:75</a></div>
                            </td>
                        </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>Member layer positions relative to the base layers array</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="name"></a>
                        <span class="name">
                            <b>
                            name</b>
                            <a href="#name"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                        </td>
                    </tr>
                        <tr>
                            <td class="col-md-4">
                                    <div class="io-line">Defined in <a href="" data-line="73" class="link-to-prism">src/main/angular-library/projects/sitmun-plugin-core/src/lib/map/map.component.ts:73</a></div>
                            </td>
                        </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>BaseLayer Group Name (to be shown in the selection list)</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
</section>







    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Component, OnInit, ViewEncapsulation, Input, ViewChild, Inject } from &#x27;@angular/core&#x27;;
import {TranslateService} from &#x27;@ngx-translate/core&#x27;;

//Openlayers imports
import * as ol from &#x27;openlayers&#x27;;
import * as proj4x from &#x27;proj4&#x27;;
/** proj4 object */
const proj4 &#x3D; (proj4x as any).default;

import {LayerSelectionDialogComponent, LayerSelectionDialogData} from &#x27;./layer-selection-dialog.component&#x27;;
import {FeatureInfoDialogComponent, FeatureInfoDialogData, FeatureInfoRequestData} from &#x27;./feature-info-dialog.component&#x27;;

//Material imports
import { MatDialog, MatDialogRef, MatDialogConfig } from &#x27;@angular/material&#x27;;

import { ElementRef } from &#x27;@angular/core&#x27;;

import {MapConfigurationManagerService, Layer, LayerConfiguration, LayerGroup, MapOptionsConfiguration, MapComponentStatus} from &#x27;./map-configuration-manager.service&#x27;;

import { Observable, of} from &#x27;rxjs&#x27;;
import { UserConfigurationService } from &#x27;../public_api&#x27;;

try {
	ol.proj.setProj4(proj4);
} catch(ex) {
  if ((typeof console !&#x3D; &quot;undefined&quot;) &amp;&amp; (typeof console.log &#x3D;&#x3D; &quot;function&quot;)) {
    console.log(&quot;Failed to load proj4js in OpenLayers&quot;);
  }
}

/** base 64 coded location image*/
const locationImg &#x3D; &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAnCAYAAABnlOo2AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAUVrAAFFawEaKylfAAAAB3RJTUUH4gUeDgsQG6NbUAAABbhJREFUWMOtmEuMFEUYx/9V3VXd8zLrsko0wZiYmBjwRpR4UExMwEQJF4KJiUbCBRMvxEQg6kEwcEBM5KBeFA+ACeADX6tLENcnykPQQEAPxA0cdmcHhpmeflR3lYep2S16u+ex0Ellemaqqn/9ff/6vq+KoP+LpO4JAGrcE6OPSjVp3MPoM+eyBoQheowFwNZAAoDEggWA7xMALgCu/7cyoLNesPuPOX2o0cKjhcJmB1jiKLWaRFGRAJCcBw3gyyYh558eGdmNiQkbQKKhBYBYf5e6zbEU6QOGACAFSi1//Xrx4/792wqt1hYkSfeBlOKy6767Kgh2UCmJBAIAoQEns1xJ+rHMEKX2awsX3vVotTpOhFg0gO4gGJvcxvmzo543kQAeAN8AS3SbsRTpBVOm1HpuZOT2ddPTl5AkLuZxKdsWGxh76pTvX5FAA22wwHDjjPtID1dZAMQJxqYgxII+NZd5xbbdXMbYcvi+AFDHrLUibSXVEWo3EVs/FYtvQYiRm4EBADuOy/uUeh3AbQAqAArGapzhoDnj26tp0SK74Psbuz3IAmBzDouxnjFkcRStGuZ8oYYqAnAMIJoXhygAwgE2FscvOUI8kfeAKmOTr7ru3s1BcOB9Kb89XyqdWwrcW5SynNVfKoV7CAnGpLyYEQqSLFGb2pHHOT9jRdHirMkbtl1/XMqdkBIwl7Rlhd8DOypJcmfWOM9xph4Lw3UArgGY0p+eHp/QLoJWVhw/kOfPPY4zqmE8Pek0gCpJksanrvthnuDKUXSH1k9BR3WmDUAAEJoTJKn+IVNjFiH4yPPO6rdqmkAKqL7jeYdt20aXXOXoxtIaojnJjnTLc0QpoFAgGsjXUNf1cr6G4eFA5kRy/UCuYVgq33Vf9iov+gLYqtQjWoiRbgEAnwDhviBYm6js0YkRUgzLkCyXzbGupHQ6M/ICWCnEkw86zlC6FFlZqQzfH0Uv500a2Xack/3b8aoLkOMxdrQSx2sy3ZYkZI+U2/5w3c+O2faRkmU1VoThsvuazQ1KqdxJz1N6Vj/XTK4zkrFzDAACkP8YG1vi+2vypldKYWkQrH4IWI3U7Hn6OanURaNomwNFc58FyOeF+JqQ3hnDLG66pg9CsFvK0zlBMTeXzdL7fjLJ2EHcouuUbZ9FHHdgIiOxzrxTHpDqUP88NLSX3AIYG8DHnP+qYQLdIqNYU1kuUykrxVsnJ3/3Ob94s0BTtl0b9bx/dOwygWLDZfka6gBRgI4XCttvxkoUwB7GviHtOX3dTCDZTUM3AEkg2lKvH/EZ+3e+QDXOa3t9/0/VBmnp1jeQuZdKAEQEoN8Vi1vpPGAsAO8x9oWer6WTccsoYZNuGkqDJQBiBYRv1Ovjdc5PDgo0wfnlg553zoAxS1eRDl+0jxATayvJnZXKpkGsxAFssaxD+sEeZgv8zs4j6RcovQ0WCgi/mp6+dLlYPNQv0HHOz/zt+1c0RNNwl7kNuiF19HrhGbd1AtkzrvumolT13O4SghcJ+VxrJcs6cVaQ76UhE0oA8L1arXGmWNzea4d5wHVHRRh6Ket0gEwxo9+da3pLZOuyswzA/YXzH3gU3Z01qMnY9eVCbNcgVQCTun6+qn8LDEFjEFGnI7cAEFBAHuD8FZqTInZZ1kHS7tvUrmqmdqtztNMv0JxACSCSgP92s3m86jjH0hNe4PzC4SA4p9oQJlBmIMwpcfu2UkdLIQCxolTaSI36hBGCFwj5QOukoevsphEI427WGdRCZhUQAfBVreb9VSrt6nQac5xPWmF4VRf715F9sKAyTtMGOrBK9+2cnrkAyuDc/k2pE0Qp/rCUayFlSQPUtYivGS6L08cvg9TUWVYiRo5rCzyKyuOFwqaYkCHSaoVqtrxoplZUkndqNl8LZYUBrkNBUX86nc2FkdX9lJi7AtkDAnWsZAq8813ojR+MEjXstczT1/9sLctpXytdQgAAAABJRU5ErkJggg&#x3D;&#x3D;&quot;;

/** measurement stroke finished color style*/
const measurementStrokeFinishedColorStyle:string &#x3D; &quot;rgba(158,17,57,1)&quot;;
/** measurement stroke measuring color style*/
const measurementStrokeMeasuringColorStyle:string &#x3D; &quot;rgba(0, 0, 0, 0.5)&quot;;
/** measurement stroke image measuring color style*/
const measurementStrokeImageMeasuringColorStyle:string &#x3D; &quot;rgba(0, 0, 0, 0.7)&quot;;
/** measurement background color style*/
const measurementBackgroundColorStyle:string &#x3D; &quot;rgba(255, 255, 255, 0.2)&quot;;

/** Map option model*/
export class MapOptions {
  /** x-coordinate of center of the map*/lon: number;
  /** y-coordinate of center of the map*/lat: number;
  /** code of the srs projection of the coordinates defined in extent, lon and lat*/projection: string;
  /** zoom of the map*/zoom: number;
  /** array of numbers representing the extent of the initial view of the map component: [minx, miny, maxx, maxy].*/extent: ol.Extent;
};

/** Map configuration model*/
export class MapConfiguration {
  /** initial zoom of the map*/initialZoom: number;
  /** x-coordinate of initial center of the map*/initialLon: number;
  /** y-coordinate of initial center of the map*/initialLat: number;
  /** code of the srs projection of the coordinates defined in extent, initialLon and initialLat*/initialProjection: string;
  /** tile height*/tileHeight: number;
  /** tile width*/tileWidth: number;
  /** map projection units*/mapUnits: string;
  /** code of the srs projection of the map*/mapProjection: string;
  /** map maximum scale*/mapMaxScale: number;
  /** map minimum scale*/mapMinScale: number;
  /** map maximum extent*/mapMaxExtent: ol.Extent;
  /** map resolutions*/mapResolutions: Array&lt;number&gt;;
};

/** Base layer group*/
export class BaseLayerGroup {
  /** BaseLayer Group Id*/
  id: string;
  /** BaseLayer Group Name (to be shown in the selection list)*/
  name: string;
  /** Member layer positions relative to the base layers array*/
  memberPositions: number[];
  /** Member layer ids*/
  memberIds: number[];
}

@Component({
  selector: &#x27;sitmun-map-viewer-map&#x27;,
  encapsulation: ViewEncapsulation.None,
  templateUrl: &#x27;./map.component.html&#x27;,
  styleUrls: [&#x27;./map.component.css&#x27;]
})

/** Map Component*/
export class MapComponent implements OnInit {

  // Default values
  /** default map projection units*/ defaultMapUnits:string &#x3D; &quot;m&quot;;
  /** default map projection*/ defaultProjection:string &#x3D; &quot;EPSG:25831&quot;;
  /** map projections*/ projections;
  /** map scales*/ scales;
  /** tile height*/ tileHeight: number &#x3D; 500;
  /** tile width*/tileWidth: number &#x3D; 500;
  /** map projection units*/ units &#x3D; &quot;m&quot;;
  /** map projection*/projection &#x3D; &quot;EPSG:25831&quot;;

  /** map maximum scale*/maxScale: number;
  /** map minimum scale*/ minScale: number;

  /** map maximum extent*/maxExtent: ol.Extent;

  /** resolutions*/ resolutions: Array&lt;number&gt;;

  /** x-coordinate of initial center of the map*/
  @Input() initialLon;
  
  /** y-coordinate of initial center of the map*/
  @Input() initialLat;
  
  /** code of the srs projection of the coordinates defined in extent, initialLon and initialLat*/
  @Input() initialProjection;
  
  /** inital zoom of the map*/
  @Input() initialZoom;

  /** reference to view mapContainer element*/
  @ViewChild(&#x27;mapContainer&#x27;) mapContainer:ElementRef;
  
  /** map extent*/
  _extent: ol.Extent;
  
  /** set map extent*/
  @Input()
  set extent(extent: ol.Extent) {  
    this._extent &#x3D; extent;
    if ((this.getMap() !&#x3D; null) &amp;&amp; (this.getMap() !&#x3D; undefined)) {
      this.setExtent(extent);
    }
  };
  
  /** load defaults value, default false*/
  _loadDefaults:boolean &#x3D; false;
  
  /** set load defaults value*/
  @Input() 
  set loadDefaults(value:boolean) {
    if (this._loadDefaults !&#x3D; value) {
      if (value) {
        this.loadDefaultMapConfiguration();
      }
      //TODO remove default configuration in else??
    }
    this._loadDefaults &#x3D; value;
  }
  
  /** get load defaults value*/  
  get loadDefaults():boolean {
    return this._loadDefaults;
  }

  /** map options*/  
  mapOptions: MapOptions;
  
  /** map controls labels*/
  messages &#x3D; {
    zoomInTooltip: &quot;Zoom in&quot;,
    zoomOutTooltip: &quot;Zoom out&quot;,
    geolocationTooltip: &quot;Locate user&quot;,
    scaleLineTooltip: &quot;Map scale&quot;,
    attributionsTooltip: &quot;Attributions&quot;,
    layerSelectionTooltip: &quot;Select base layer&quot;,
    getFeatureInfoTooltip: &quot;Information from cartography&quot;,
    overviewTooltip: &quot;Overview map&quot;,
    lenghtTooltip: &quot;Length measurement&quot;,
    areaTooltip: &quot;Area measurement&quot;,
    continueLineMsg: &quot;Click to continue drawing the line&quot;,
    continuePolygonMsg: &quot;Click to continue drawing the polygon&quot;
  };

  /** translate map controls labels*/
  translateLabels() {
    this.messages[&quot;zoomInTooltip&quot;] &#x3D; this.translate.instant(&quot;ZOOM_IN_TOOLTIP&quot;);
    this.messages[&quot;zoomOutTooltip&quot;] &#x3D; this.translate.instant(&quot;ZOOM_OUT_TOOLTIP&quot;);
    this.messages[&quot;geolocationTooltip&quot;] &#x3D; this.translate.instant(&quot;LOCATION_TOOLTIP&quot;);
    this.messages[&quot;scaleLineTooltip&quot;] &#x3D; this.translate.instant(&quot;SCALE_BAR_TOOLTIP&quot;);
    this.messages[&quot;attributionsTooltip&quot;] &#x3D; this.translate.instant(&quot;ATTRIBUTIONS_TOOLTIP&quot;);
    this.messages[&quot;layerSelectionTooltip&quot;] &#x3D; this.translate.instant(&quot;BASE_LAYER_SELECTOR_TOOLTIP&quot;);
    this.messages[&quot;getFeatureInfoTooltip&quot;] &#x3D; this.translate.instant(&quot;GET_FEATURE_INFO_TOOLTIP&quot;);
    this.messages[&quot;overviewTooltip&quot;] &#x3D; this.translate.instant(&quot;OVERVIEW_MAP_TOOLTIP&quot;);
    this.messages[&quot;lengthTooltip&quot;] &#x3D; this.translate.instant(&quot;LENGTH_MEASUREMENT_TOOLTIP&quot;);
    this.messages[&quot;areaTooltip&quot;] &#x3D; this.translate.instant(&quot;AREA_MEASUREMENT_TOOLTIP&quot;);
    this.messages[&quot;continueLineMsg&quot;] &#x3D; this.translate.instant(&quot;CONTINUE_LINE_MSG&quot;);
    this.messages[&quot;continuePolygonMsg&quot;] &#x3D; this.translate.instant(&quot;CONTINUE_POLYGON_MSG&quot;);
    this.updateTranslations();
  }

  /** update map controls labels translations */
  updateTranslations() {
    //zoom
    if (this.zoomToolControl) {
      var nodes &#x3D; document.getElementsByClassName(&quot;ol-zoom-in&quot;);
      if (nodes &amp;&amp; (nodes.length &gt; 0)) {
        nodes[0].setAttribute(&quot;title&quot;, this.messages[&quot;zoomInTooltip&quot;]);
      }
      nodes &#x3D; document.getElementsByClassName(&quot;ol-zoom-out&quot;);
      if (nodes &amp;&amp; (nodes.length &gt; 0)) {
        nodes[0].setAttribute(&quot;title&quot;, this.messages[&quot;zoomOutTooltip&quot;]);
      }
    }

    //attributions
    if (this.attributionToolControl) {
      var nodes &#x3D; document.getElementsByClassName(&quot;ol-attribution-btn&quot;);
      if (nodes &amp;&amp; (nodes.length &gt; 0)) {
        nodes[0].setAttribute(&quot;title&quot;, this.messages[&quot;attributionsTooltip&quot;]);
      }
    }

    //overview
    if (this.overViewMapControl) {
      var nodes &#x3D; document.getElementsByClassName(&quot;ol-overviewmap-btn&quot;);
      if (nodes &amp;&amp; (nodes.length &gt; 0)) {
        nodes[0].setAttribute(&quot;title&quot;, this.messages[&quot;overviewTooltip&quot;]);
      }
    }

    //geolocation
    if (this.locationToolControl) {
      this.locationToolControl.updateTooltip(this.messages[&quot;geolocationTooltip&quot;]);
    }

    //scalebar
    if (this.scaleLineToolControl) {
      this.scaleLineToolControl.updateTooltip(this.messages[&quot;scaleLineTooltip&quot;]);
    }

    //layer selector
    if (this.selectBaseLayerControl) {
      this.selectBaseLayerControl.updateTooltip(this.messages[&quot;layerSelectionTooltip&quot;]);
    }

    //layer selector
    if (this.getFeatureInfoControl) {
      this.getFeatureInfoControl.updateTooltip(this.messages[&quot;getFeatureInfoTooltip&quot;]);
    }

    //measurement
    if (this.measurementToolControl) {
      this.measurementToolControl.updateMessages({
        lengthTooltip: this.messages[&quot;lengthTooltip&quot;],
        areaTooltip: this.messages[&quot;areaTooltip&quot;],
        continueLineMsg: this.messages[&quot;continueLineMsg&quot;],
        continuePolygonMsg: this.messages[&quot;continuePolygonMsg&quot;]
      });
    }
  }

  /** translate service*/ 
  translate: TranslateService;
  
  /** constructor*/
  constructor(private dialog: MatDialog, 
    private featureInfoDialog: MatDialog,
    private mapConfigurationManagerService: MapConfigurationManagerService,
    translate: TranslateService) {
    this.translate &#x3D; translate;
    this.translate.onLangChange.subscribe(() &#x3D;&gt; {
        this.translateLabels();
    });
    this.translateLabels();
  }
  
  /** OpenLayers map */
  map: ol.Map &#x3D; null;

  setExtent(extent: ol.Extent) {
    if ((extent !&#x3D; null) &amp;&amp; (extent !&#x3D; undefined)) {
      this.getMap().getView().fit(extent);
      this.getMap().getView().setZoom(
        this.getMap().getView().getZoomForResolution(
          this.getMap().getView().getResolutionForExtent(extent)));
    }
  }
  
  /** get OpenLayers map */
  getMap(){
    return this.map;
  }

  // MapConfigurationManagerService event subscriptors
  /** layers events subscription*/
  layerSubscription;
  
  /** base layers events subscription*/
  baseLayersSubscription;
  
  /** layer configuration events subscription*/
  layerConfigurationSubscription;
  
  /** add layer events subscription*/
  addLayersSubscription;
  
  /** remove layer events subscription*/
  removeLayersSubscription;
  
  /** situation map events subscription*/
  situationMapConfigurationSubscription;
  
  /** map options events subscription*/
  mapOptionsConfigurationSubscription;

  /** show message on console*/ 
  showMessage(msg:string) {
    if (console &amp;&amp; (typeof console.log &#x3D;&#x3D; &quot;function&quot;)) {
      console.log(msg);
    }
  }

  /** initialize MapConfigurationManager*/
  initializeMapConfigurationManager(): void {
    this.layerSubscription &#x3D; this.mapConfigurationManagerService.getLayers().subscribe(
      layers &#x3D;&gt; {
                  this.configureLayers(layers);
                },
      error &#x3D;&gt; this.showMessage(&quot;error configuration&quot;),
      () &#x3D;&gt; this.showMessage(&quot;on complete configuration&quot;)
    );
    this.addLayersSubscription &#x3D; this.mapConfigurationManagerService.getLayersAdded().subscribe(
      layers &#x3D;&gt; {
                  this.addLayers(layers);
                },
      error &#x3D;&gt; this.showMessage(&quot;error configuration&quot;),
      () &#x3D;&gt; this.showMessage(&quot;on complete configuration&quot;)
    );
    this.removeLayersSubscription &#x3D; this.mapConfigurationManagerService.getLayersRemoved().subscribe(
      layers &#x3D;&gt; {
                  this.removeLayers(layers);
                },
      error &#x3D;&gt; this.showMessage(&quot;error configuration&quot;),
      () &#x3D;&gt; this.showMessage(&quot;on complete configuration&quot;)
    );
    this.layerConfigurationSubscription &#x3D; this.mapConfigurationManagerService.getLayerConfigurationListener().subscribe(
      configurations &#x3D;&gt; {
                  for (var i &#x3D; 0, iLen &#x3D; configurations.length; i &lt; iLen; i++) {
                    this.applyLayerConfiguration(configurations[i]);
                  }
                },
      error &#x3D;&gt; this.showMessage(&quot;error displayed&quot;),
      () &#x3D;&gt; this.showMessage(&quot;on complete displayed&quot;)
    );
    this.baseLayersSubscription &#x3D; this.mapConfigurationManagerService.getBaseLayerGroups().subscribe(
      baseLayerGroups &#x3D;&gt; {
                  this.configureBaseLayers(baseLayerGroups);
                },
      error &#x3D;&gt; this.showMessage(&quot;error displayed&quot;),
      () &#x3D;&gt; this.showMessage(&quot;on complete displayed&quot;)
    );
    this.situationMapConfigurationSubscription &#x3D; this.mapConfigurationManagerService.getSituationMapConfigurationListener().subscribe(
      layers &#x3D;&gt; {
                  this.situationMapLayers &#x3D; [];
                  this.parseLayers(this.situationMapLayers, layers);
                  this.updateOverviewMap();
                },
      error &#x3D;&gt; this.showMessage(&quot;error configuration&quot;),
      () &#x3D;&gt; this.showMessage(&quot;on complete configuration&quot;)
    );
    this.mapOptionsConfigurationSubscription &#x3D; this.mapConfigurationManagerService.getMapOptionsConfigurationListener().subscribe(
      options &#x3D;&gt; {
                  if (options &amp;&amp; (options.length &gt; 0)) {
                    this.updateMapOptions(options[0]);
                  }
                },
      error &#x3D;&gt; this.showMessage(&quot;error configuration&quot;),
      () &#x3D;&gt; this.showMessage(&quot;on complete configuration&quot;)
    );
  }
  
  /** set default map projection units*/
  setDefaultMapUnits(units) {
    if (units) {
      this.defaultMapUnits &#x3D; units;
    }
  }
  
  /** get default map projection units*/
  getDefaultMapUnits():string {
    return this.defaultMapUnits;
  }

  /** set default map projection*/
  setDefaultProjection(projection) {
    if (projection) {
      this.defaultProjection &#x3D; projection;
    }
  }
  
  /** get default map projection*/
  getDefaultProjection():string {
    return this.defaultProjection.slice();//Return the value cloned
  }

  /** get projection units*/
  getProjectionUnits(projection) {
    try {
      var prj &#x3D; ol.proj.get(projection);
      if (prj) {
        return prj.getUnits();
      } else {
        return &quot;m&quot;;
      }
    } catch (e) {
      return &quot;m&quot;;
    }
  }

  /** set map projection*/
  setProjection(projectionList:any) {
    var projection:ol.proj.Projection &#x3D; null;
    
    for (var i &#x3D; 0, iLen &#x3D; projectionList.length; i &lt; iLen; i++) {
      projection &#x3D; ol.proj.get(projectionList[i]);
      if (projection) {
        break;
      }
    }
    if (projection !&#x3D; null) {
      this.projection &#x3D; projection.getCode();
    }
  }

  /** transform projection of given coordinates (lonlat) from given source projection to given destination projection*/
  transformLonLat(lonlat, projectionFrom:string, projectionTo:string) {
    if (lonlat) {
      return ol.proj.transform(lonlat, new ol.proj.Projection({
        code: projectionFrom
      }), new ol.proj.Projection({
        code: projectionTo
      }));
    }
    return null;
  }

  /** transform projection of given extentfrom given source projection to given destination projection*/
  transformExtent(extent, projectionFrom:string, projectionTo:string) {
    if (extent) {
      return ol.extent.applyTransform(
        [extent[0], extent[1], extent[2], extent[3]], 
          ol.proj.getTransform(new ol.proj.Projection({
            code: projectionFrom
          }), new ol.proj.Projection({
            code: projectionTo
          })));
    }
    return null;
  }

  /** update map options with given data*/
  updateMapOptions(options:MapOptionsConfiguration) {
    if (!options) {
      //If no options defined load default values
      this.updateMapOptions(this.getDefaultMapOptionsConfiguration());
      return;
    }

    if (options.projections) {
      this.projections &#x3D; options.projections.split(&#x27;,&#x27;);
      if (this.projections.length &#x3D;&#x3D; 0) {
        this.projections &#x3D; [this.getDefaultProjection()]
      } else {
        this.projections.forEach(function(projection, index, projections) {
          projections[index] &#x3D; projection.trim();
        });
      }
    } else {
      this.projections &#x3D; [this.getDefaultProjection()]
    }

    if (options.scales) {
      var scales &#x3D; options.scales.split(&#x27;,&#x27;);
      if (scales.length) {
        this.scales &#x3D; [];
        for (var i &#x3D; 0, iLen &#x3D; scales.length; i&lt;iLen; i++) {
          if ((scales[i] !&#x3D; undefined) &amp;&amp; (scales[i] !&#x3D; null) &amp;&amp; (scales[i] !&#x3D; &quot;&quot;)) {
            this.scales.push(parseFloat(scales[i].trim()));
          }
        }
      } else {
        this.scales &#x3D; [];
        this.scales &#x3D; this.scales.concat(this.getDefaultMapScales());
      }
    } else {
      this.scales &#x3D; [];
      this.scales &#x3D; this.scales.concat(this.getDefaultMapScales());
    }
    
    if ((options.tileHeight !&#x3D; undefined) &amp;&amp; (options.tileHeight !&#x3D; null)) {
      this.tileHeight &#x3D; options.tileHeight;
    }
    if ((options.tileWidth !&#x3D; undefined) &amp;&amp; (options.tileWidth !&#x3D; null)) {
      this.tileWidth &#x3D; options.tileWidth;
    }

    var maxZoom &#x3D; this.scales.length-1;
    if (options.maxScale) {
      this.maxScale &#x3D; options.maxScale;
      var normalizedMaxScale &#x3D; this.maxScale&gt;1.0?(1.0/this.maxScale):this.maxScale;
      var scale, prevScale;
      for (var i &#x3D; 0, iLen:number &#x3D; this.scales.length; i &lt; iLen; i++) {
        scale &#x3D; this.scales[i];
        if (scale &gt; 1.0) {
          scale &#x3D; 1.0/scale;
        }
        if (scale &lt; normalizedMaxScale) {
          //Get the closest zoom level one
          var factor &#x3D; 0;
          if (i &gt; 0) {
            prevScale &#x3D; this.scales[i-1];
            if (prevScale &gt; 1.0) {
              prevScale &#x3D; 1.0/prevScale;
            }
            if (Math.abs(normalizedMaxScale-scale) &gt; 
                Math.abs(normalizedMaxScale-prevScale)) {
              //Closest to the prevous one
              factor &#x3D; 1;
            }
          }
          maxZoom &#x3D; this.scales.length-i-factor-1;
          break;
        }
      }
    } else {
      this.maxScale &#x3D; this.scales[this.scales.length-1];
    }

    var minZoom &#x3D; 0;
    if (options.minScale) {
      this.minScale &#x3D; options.minScale;
    } else {
      this.minScale &#x3D; this.scales[0];
    }
    
    var maxExtent;
    if (options.maxExtent &amp;&amp; options.projections) { 
      //The extent&#x27;s projection is assumed to be the first on the list
      maxExtent &#x3D; options.maxExtent;
    }

    if (options.parameters) {
      for (var i &#x3D; 0, iLen &#x3D; options.parameters.length; i &lt; iLen; i++) {
        //TODO parse other options
      }
    }

    var oldProjection &#x3D; this.projection + &quot;&quot;;//Clone current projection
    this.projection &#x3D; this.projections[0];
    var currentExtent &#x3D; this.getMap().getView().calculateExtent();
    if (oldProjection !&#x3D; this.projection) {
      currentExtent &#x3D; this.transformExtent(currentExtent, 
                            oldProjection, this.projection);
    }

    this.units &#x3D; this.getProjectionUnits(this.projection);

    var resolutions &#x3D; this.getResolutionsFromScales(this.scales, this.units);
    if (resolutions) {
      this.resolutions &#x3D; resolutions;
    } else {
      this.resolutions &#x3D; this.getResolutionsFromScales(this.getDefaultMapScales(), this.units);
      if (!this.resolutions) {
        this.resolutions &#x3D; this.getDefaultMapResolutions();
      }
    }

    var viewOptions &#x3D; {
      projection: new ol.proj.Projection({
        code: this.projection,
        units: this.units
      }),        
      resolutions: this.resolutions,
      zoom: 0
    };

    if (maxExtent) {
      this.maxExtent &#x3D; maxExtent;
      viewOptions[&quot;extent&quot;] &#x3D; this.maxExtent;
    } else {
      //No max extent restriction
      this.maxExtent &#x3D; null;
    }

    var extent;
    if (options.extent) {
      extent &#x3D; options.extent;
    } else {
      if (this.maxExtent) {
        extent &#x3D; this.maxExtent;
      } else {
        //Use the transformed current extent
        extent &#x3D; currentExtent;
      }
    }

    var view &#x3D; new ol.View(viewOptions);

    if (this.getMap()) {
      this.getMap().setView(view);
      //FIXME force layer repojection 
      //update controls with event listeners
      if (this.overViewMapControl) {
        //Define center otherwise an error is raised
        if (extent) {
			    viewOptions[&quot;center&quot;] &#x3D; ol.extent.getCenter(extent);
        }
        this.overViewMapControl.getOverviewMap().setView(
          new ol.View(viewOptions)
        );
      }
      if (this.scaleLineToolControl !&#x3D; null) {
        this.scaleLineToolControl.updateMap(this.getMap());
      }
      if (extent) {
        //Set the map and overview map centers
        view.fit(extent);
      }
    }
  }

  /** get resolutions from given scales*/ 
  getResolutionsFromScales(scales:number[], units?):number[] {
    var resolutions &#x3D; [];
    for (var i &#x3D; 0, iLen &#x3D; scales.length; i &lt; iLen; i++) {
      resolutions.push(MapComponent.getResolutionFromScale(scales[i], units));
    }
    return resolutions;
  }

  /** get scales from given resolutions*/ 
  getScalesFromResolutions(resolutions:number[], units?):number[] {
    var scales &#x3D; [];
    for (var i &#x3D; 0, iLen &#x3D; resolutions.length; i &lt; iLen; i++) {
      scales.push(MapComponent.getScaleFromResolution(resolutions[i], units));
    }
    return scales;
  }
  
  /** parse layers from array of layers*/ 
  parseLayers(layers, layerDataConfig:Array&lt;Layer&gt;) {
    if (!layerDataConfig || !layerDataConfig.length) {
      return;
    }
    if (!layers) {
      layers &#x3D; [];
    }
    var layer;
    var properties;
    var layerParams;
    var projection;

    for (var i &#x3D; 0, iLen:number &#x3D; layerDataConfig.length; i &lt; iLen; i++) {
      layerParams &#x3D; {
        &quot;LAYERS&quot;:layerDataConfig[i].name,
        &quot;TRANSPARENT&quot;: layerDataConfig[i].url_transparent?layerDataConfig[i].url_transparent.toUpperCase():&quot;FALSE&quot;,
        &quot;BGCOLOR&quot;: layerDataConfig[i].url_bgcolor,
        &quot;VERSION&quot;: layerDataConfig[i].version,
        &quot;FORMAT&quot;: this.parseFormat(layerDataConfig[i].format),
        &quot;EXCEPTION&quot;: layerDataConfig[i].url_exception
      };
      if (layerDataConfig[i].optionalParameters) {
        for (var j &#x3D; 0, jLen &#x3D; layerDataConfig[i].optionalParameters.length; j &lt; jLen; j++) {
          try {
            layerParams[layerDataConfig[i].optionalParameters[j].key] &#x3D; layerDataConfig[i].optionalParameters[j].value;
          } catch (e) {
            //ignore those params that generate an exception
          }
        }
      }         
      properties &#x3D; null;
      if ((layerDataConfig[i].id !&#x3D; undefined) &amp;&amp; (layerDataConfig[i].id !&#x3D; null)) {
        properties &#x3D; {
          id: layerDataConfig[i].id
        }
      }
      if ((layerDataConfig[i].serverName !&#x3D; undefined) &amp;&amp; (layerDataConfig[i].serverName !&#x3D; null)) {
        if (properties &#x3D;&#x3D; null) {
          properties &#x3D; {
            serverName: layerDataConfig[i].serverName
          };
        } else {
          properties[&quot;serverName&quot;] &#x3D; layerDataConfig[i].serverName;
        }
      }
      if (layerDataConfig[i].title) {
        if (properties &#x3D;&#x3D; null) {
          properties &#x3D; {
            queryable: layerDataConfig[i].title
          };
        } else {
          properties[&quot;title&quot;] &#x3D; layerDataConfig[i].title;
        }
      }
      if (layerDataConfig[i].queryable) {
        if (properties &#x3D;&#x3D; null) {
          properties &#x3D; {
            queryable: layerDataConfig[i].queryable
          };
        } else {
          properties[&quot;queryable&quot;] &#x3D; layerDataConfig[i].queryable;
        }
      }
      if ((layerDataConfig[i].projections !&#x3D; undefined) &amp;&amp; (layerDataConfig[i].projections !&#x3D; null)) {
        var projections &#x3D; layerDataConfig[i].projections.split(&#x27;,&#x27;);
        projections.forEach(function(projection, index, projections) {
          projections[index] &#x3D; projection.trim();
        });
        if (properties &#x3D;&#x3D; null) {
          properties &#x3D; {
            projections: projections
          };
        } else {
          properties[&quot;projections&quot;] &#x3D; projections;
        }
        projection &#x3D; projections[0];
      } else {
		    projection &#x3D; this.projection;
      }
      if (layerDataConfig[i].tiled) {
         layer &#x3D; new ol.layer.Tile({
              minResolution:layerDataConfig[i].minimumScale?
                            MapComponent.getResolutionFromScale(layerDataConfig[i].minimumScale):undefined,
              maxResolution:layerDataConfig[i].maximumScale?
                            MapComponent.getResolutionFromScale(layerDataConfig[i].maximumScale):undefined,
              extent: layerDataConfig[i].extent?
                        [layerDataConfig[i].extent[0], layerDataConfig[i].extent[1], layerDataConfig[i].extent[2], layerDataConfig[i].extent[3]]:
                          undefined,
              source: new ol.source.TileWMS({
                url: layerDataConfig[i].url,
                params: layerParams,
                projection: projection + &quot;&quot;,//Clone the value
                attributions: layerDataConfig[i].attributions,
                // Countries have transparency, so do not fade tiles:
                transition: 0,
                tileGrid: new ol.tilegrid.TileGrid({
                  extent: layerDataConfig[i].extent?
                          [layerDataConfig[i].extent[0], layerDataConfig[i].extent[1], layerDataConfig[i].extent[2], layerDataConfig[i].extent[3]]:
                            undefined,
                  resolutions: this.resolutions,
                  tileSize: [layerDataConfig[i].tileWidth?
                              layerDataConfig[i].tileWidth:
                              this.tileWidth, 
                              layerDataConfig[i].tileHeight?
                              layerDataConfig[i].tileHeight:
                              this.tileHeight]
                })
              }),
              visible:layerDataConfig[i].visibility/*,
              //WMTS do not take into account any opacity defined
              opacity:
                      layerDataConfig[i].opacity? 
                        layerDataConfig[i].opacity:undefined*/
          });
        layer.setProperties(properties);
        layers.push(layer);
      } else {  
        layer &#x3D; new ol.layer.Image({
            minResolution:layerDataConfig[i].minimumScale?
                          MapComponent.getResolutionFromScale(layerDataConfig[i].minimumScale):undefined,
            maxResolution:layerDataConfig[i].maximumScale?
                          MapComponent.getResolutionFromScale(layerDataConfig[i].maximumScale):undefined,
            extent: layerDataConfig[i].extent?
              [layerDataConfig[i].extent[0], layerDataConfig[i].extent[1], layerDataConfig[i].extent[2], layerDataConfig[i].extent[3]]:
                undefined,
            source: new ol.source.ImageWMS({
              url: layerDataConfig[i].url,
              params: layerParams,
              projection: projection + &quot;&quot;,//clone the value
              //ratio: 1,
              attributions: layerDataConfig[i].attributions
            }),
            visible:layerDataConfig[i].visibility,
            opacity:
                    layerDataConfig[i].opacity? 
                      layerDataConfig[i].opacity:undefined
          });
        layer.setProperties(properties);
        layers.push(layer);
      }
      layers[layers.length-1].baselayer &#x3D; layerDataConfig[i].isBaseLayer;
    }
  }

  /** get map layer by given id*/
  getMapLayerById(id:string):ol.layer.Base {
    var layer &#x3D; null;
    if (this.map) {
      var layer;
      var layerArray &#x3D; this.map.getLayers();
      for (var i &#x3D; 0, iLen &#x3D; layerArray.getLength(); i &lt; iLen; i++) {
        if (layerArray.item(i).getProperties()[&quot;id&quot;] &#x3D;&#x3D; id) {
          layer &#x3D; layerArray.item(i);
          break;
        }
      }
    }
    return layer;
  }

  /** get map layer index by given id*/
  getMapLayerIndexById(id:string):number {
    var index &#x3D; -1;
    if (this.map) {
      var layer;
      var layerArray &#x3D; this.map.getLayers();
      for (var i &#x3D; 0, iLen &#x3D; layerArray.getLength(); i &lt; iLen; i++) {
        if (layerArray.item(i).getProperties()[&quot;id&quot;] &#x3D;&#x3D; id) {
          index &#x3D; i;
          break;
        }
      }
    }
    return index;
  }

  /** layers*/
  layers;
  
  /** configure given array of layers*/
  configureLayers(layerDataConfig:Array&lt;Layer&gt;) {
    if (layerDataConfig) {
      if (this.layers &amp;&amp; (this.layers.length)) {
        if (this.loadingControl) {
          //Hide loading control
          this.loadingControl.reset();
        }
        //Clear non base layers
        if (this.map) {
          var layer;
          for (var i &#x3D; 0, iLen:number &#x3D; this.layers.length; i &lt; iLen; i++) {
            layer &#x3D; this.layers[i];
            if (layer &amp;&amp; layer.getProperties() &amp;&amp; layer.getProperties()[&quot;loading&quot;]) {
              layer.setProperties({loading: false});
              if (this.loadingControl) {
                this.loadingControl.addLoaded();
              }
            }
            this.map.removeLayer(layer);
          }
          while(this.layers.length) {
            this.layers.pop();
          }
        }
      } else {
        this.layers &#x3D; [];
      }
      this.addLayers(layerDataConfig);
    }
  }

  /** loadingControl*/
  loadingControl;
  
  /** add given array of layers to map*/
  addLayers(layerDataConfig:Array&lt;Layer&gt;) {
    if (layerDataConfig) {
      var newLayers &#x3D; [];
      this.parseLayers(newLayers, layerDataConfig);
  
      if (newLayers &amp;&amp; this.map) {
        var layer;
        var source;
        var layerIndex;
        var loadingControl_ &#x3D; this.loadingControl;
        var getFeatureInfoControl_ &#x3D; this.getFeatureInfoControl;
        //Add the layers at the end of the map layers array
        for (var i &#x3D; 0, iLen:number &#x3D; newLayers.length; i &lt; iLen; i++) {
          layer &#x3D; newLayers[i];
          layerIndex &#x3D; this.getMapLayerIndexById(layer.getProperties()[&quot;id&quot;]);
          if (layerIndex &#x3D;&#x3D; -1){
            //Avoid duplicates
            this.map.addLayer(layer);
            if (loadingControl_ &amp;&amp; !(layer.getSource() instanceof ol.source.TileWMS)) {
              source &#x3D; layer.getSource();  
              source.on(&#x27;imageloadstart&#x27;, function() {
                if (layer.getProperties() &amp;&amp; !layer.getProperties()[&quot;loading&quot;]) {
                  layer.setProperties({loading: true});
                  loadingControl_.addLoading();
                }
              });  
              source.on(&#x27;imageloadend&#x27;, function() {
                if (layer.getProperties() &amp;&amp; layer.getProperties()[&quot;loading&quot;]) {
                  layer.setProperties({loading: false});
                  loadingControl_.addLoaded();
                }
              });
              source.on(&#x27;imageloaderror&#x27;, function() {
                if (layer.getProperties() &amp;&amp; layer.getProperties()[&quot;loading&quot;]) {
                  layer.setProperties({loading: false});
                  loadingControl_.addLoaded();
                }
              });
              layer.on(&#x27;change:visible&#x27;, function(){
                if (!layer.getVisible()) {
                  if (layer.getProperties() &amp;&amp; layer.getProperties()[&quot;loading&quot;]) {
                    //Cancel the loading request
                    layer.setProperties({loading: false});
                    loadingControl_.addLoaded();
                  }
                  if (getFeatureInfoControl_ !&#x3D; null) {
                    getFeatureInfoControl_.updateVisibleLayers(layer.getVisible());    
                  }
                } else {
                }
              });
            } else if (getFeatureInfoControl_ !&#x3D; null) {
              layer.on(&#x27;change:visible&#x27;, function(){
                getFeatureInfoControl_.updateVisibleLayers(layer.getVisible());
                if (!layer.getVisible()) {
                  if (layer.getProperties() &amp;&amp; layer.getProperties()[&quot;loading&quot;]) {
                    //Cancel the loading request
                    layer.setProperties({loading: false});
                    loadingControl_.addLoaded();
                  }
                }
              });
            }
          } else {
            //Update visibility
            this.map.getLayers().item(layerIndex).setVisible(layer.getVisible());
          }
        }
      }
  
      if (this.layers &#x3D;&#x3D; null) {
        this.layers &#x3D; [];
      }
      this.layers &#x3D; this.layers.concat(newLayers);
  
      this.updateVectorDataLayers();

      if (this.getFeatureInfoControl !&#x3D; null) {
        this.getFeatureInfoControl.onDataChanged({
          layers: this.getQueryableLayers()
        });
      }
    }
  }
  
  /** remove given array of layers to map*/
  removeLayers(layerDataConfig:Array&lt;Layer&gt;) {

    if (layerDataConfig &amp;&amp; this.map) {
      //Add the layers at the end of the map layers array
      var layerToRemove;
      var layer;
      var indexToRemove;

      if (!layerDataConfig.length || !layerDataConfig[0]) {
        return;
      }

      for (var i &#x3D; 0, iLen &#x3D; layerDataConfig.length; i &lt; iLen; i++) {
        layer &#x3D; layerDataConfig[i];
        layerToRemove &#x3D; this.getMapLayerById(layer.id);
        if (layerToRemove !&#x3D; null) {
          if (layerToRemove.getProperties() &amp;&amp; layerToRemove.getProperties()[&quot;loading&quot;]) {
            layerToRemove.setProperties({loading: false});
            if (this.loadingControl) {
              this.loadingControl.addLoaded();
            }
          }
          this.map.removeLayer(layerToRemove);
        }
        //Update layers
        if (this.layers !&#x3D; null) {
          indexToRemove &#x3D; -1;
          for (var j &#x3D; 0, jLen &#x3D; this.layers.length; j &lt; jLen; j++) {
            if (this.layers[j].getProperties()[&quot;id&quot;] &#x3D;&#x3D; layer.id) {
              indexToRemove &#x3D; j;
              break;
            }
            if (indexToRemove !&#x3D; -1) {
              this.layers.splice(indexToRemove,1);
            }
          }

        }
      }
    }
  }
  
  /** apply given layer configuration*/
  applyLayerConfiguration(configuration: LayerConfiguration) {
    if (configuration &amp;&amp; this.map) {
      var layer &#x3D; this.getMapLayerById(configuration.id);
      var pos &#x3D; this.getMapLayerIndexById(configuration.id);
      if (layer) {
        if ((configuration.opacity !&#x3D; undefined) &amp;&amp; (configuration.opacity !&#x3D; null)) {
          layer.setOpacity(configuration.opacity);
        }
        if ((configuration.visibility !&#x3D; undefined) &amp;&amp; (configuration.visibility !&#x3D; null)) {
          layer.setVisible(configuration.visibility);
        }
        if ((configuration.position !&#x3D; undefined) &amp;&amp; (configuration.position !&#x3D; null) &amp;&amp;
            (configuration.position &gt;&#x3D; 0)) {
          if (layer.getProperties() &amp;&amp; layer.getProperties()[&quot;loading&quot;]) {
            layer.setProperties({loading: false});
            if (this.loadingControl) {
              this.loadingControl.addLoaded();
            }
          }
          this.map.removeLayer(layer);
          var baseIndex &#x3D; this.baseLayers?this.baseLayers.length:0;
          this.map.getLayers().insertAt(configuration.position+baseIndex, layer);
        }
      }
    }
  }
  
  /** update vector added layers*/
  updateVectorDataLayers() {
    if (this.map !&#x3D; null) {
      this.map.dispatchEvent(&quot;layersadded&quot;);  
    }
  }

  /** base layers*/
  baseLayers;
  
  /** base layers gorups*/
  baseLayerGroups;
  
  /** select base layer control*/
  selectBaseLayerControl;
  
  /** situation layers*/
  situationMapLayers;
  
  /** GetFeatureInfo control*/
  getFeatureInfoControl;
  
  /** configure given array of group of layers as base layers*/
  configureBaseLayers(groups:Array&lt;LayerGroup&gt;) {
    var groupNames;
    if ((groups !&#x3D; null) &amp;&amp; (groups !&#x3D; undefined)) {

      var baseLayersArray &#x3D; [];
      var layersArray &#x3D; [];

      var layersNamesArray &#x3D; [];
      var layer;
      var group;

      var layerIndex &#x3D; 0;
      var isBaseLayerIndex &#x3D; 0;
      var baseLayerGroup:BaseLayerGroup;
      this.baseLayerGroups &#x3D; [];
      var selectedGroup &#x3D; 0;
      groupNames &#x3D; [];
      for (var i &#x3D; 0, iLen &#x3D; groups.length; i &lt; iLen; i++) {
        group &#x3D; groups[i];
        
        baseLayerGroup &#x3D; new BaseLayerGroup();
        baseLayerGroup.id &#x3D; group.id;
        if ((group.name !&#x3D; undefined) &amp;&amp; (group.name !&#x3D; null)) {
          baseLayerGroup.name &#x3D; group.name;
        } else {
          baseLayerGroup.name &#x3D; baseLayerGroup.id;
        }
        groupNames.push(baseLayerGroup.name);

        baseLayerGroup.memberIds &#x3D; [];
        baseLayerGroup.memberPositions &#x3D; [];
        for (var j &#x3D; 0, jLen &#x3D; group.layers.length; j &lt; jLen; j++) {
          layer &#x3D; group.layers[j];
          layerIndex &#x3D; layersNamesArray.indexOf(layer.serverName);
          if (layerIndex &#x3D;&#x3D; -1) {
            if (layer.isBaseLayer) {
              baseLayersArray.push(layer);
            } else {
              layersArray.push(layer);
            }
            layersNamesArray.push(layer.serverName);
          }
          baseLayerGroup.memberIds.push(layer.serverName);
        }
        this.baseLayerGroups.push(baseLayerGroup);
        if (group.active) {
          selectedGroup &#x3D; i;
        }
      }
    }
    if (this.baseLayers &amp;&amp; (this.baseLayers.length)) {
      //Clear non base layers
      if (this.map) {
        for (var i &#x3D; 0, iLen:number &#x3D; this.baseLayers.length; i &lt; iLen; i++) {
          this.map.removeLayer(this.baseLayers[i]);
        }
        while(this.baseLayers.length) {
          this.baseLayers.pop();
        }
      }
    } else {
      if (!this.baseLayers) {
        this.baseLayers &#x3D; [];
      }
      if (!this.baseLayerGroups) {
        this.baseLayerGroups &#x3D; [];
      }
    }

    //Concatenate the base layers with the other non base layers
    layersArray &#x3D; baseLayersArray.concat(layersArray);
    var layer;
    //Update layer insertion index to make it visible upon selecting the corresponding base layer group
    for (var i &#x3D; 0, iLen &#x3D; layersArray.length; i &lt; iLen; i++) {
      layer &#x3D; layersArray[i];
      for (var j &#x3D; 0, jLen &#x3D; this.baseLayerGroups.length; j &lt; jLen; j++) {
        baseLayerGroup &#x3D; this.baseLayerGroups[j];
        if (baseLayerGroup.memberIds.indexOf(layer.serverName) !&#x3D; -1) {
          baseLayerGroup.memberPositions.push(i);
          break;
        }
      }
    }

    //Calculate the insertion indexes for each group
    this.parseLayers(this.baseLayers, layersArray);
    if (this.baseLayers &amp;&amp; this.map) {
      var index &#x3D; 0;
      var layer;
      var source;
      var getFeatureInfoControl_ &#x3D; this.getFeatureInfoControl;
      //Add the layers at the beginning of the map layers array
      for (var i &#x3D; 0, iLen:number &#x3D; this.baseLayers.length; i &lt; iLen; i++) {
        layer &#x3D; this.baseLayers[i];
        this.map.getLayers().insertAt(index++, layer);
        if (getFeatureInfoControl_ !&#x3D; null) {
          layer.on(&#x27;change:visible&#x27;, function(){
            getFeatureInfoControl_.updateVisibleLayers(layer.getVisible());
          });
        }
      }
      if (this.selectBaseLayerControl) {
        this.selectBaseLayerControl.onDataChanged({
          layerGroups: this.baseLayerGroups,
          groupNames: groupNames,
          layers: this.baseLayers,
          selection: selectedGroup
        });
      }

      if (!this.situationMapLayers || 
        (this.situationMapLayers.length &#x3D;&#x3D; 0)) {
        //If there is no situation map configuration loaded then reload the overview with the new base layers
        this.updateOverviewMap();
      }

      if (this.getFeatureInfoControl !&#x3D; null) {
        this.getFeatureInfoControl.onDataChanged({
          layers: this.getQueryableLayers()
        });
      }
    }
  }

  /** get queryable layers*/
  getQueryableLayers() {
    var queryableLayers &#x3D; null;
    if (this.getMap() &amp;&amp; this.getMap().getLayers() !&#x3D; null) {
      this.getMap().getLayers().forEach(function (layer, index, layers) {
        if (layer.getProperties()[&quot;queryable&quot;]) {
          if (queryableLayers &#x3D;&#x3D; null) {
            queryableLayers &#x3D; [];
          }
          queryableLayers.push(layer);
        }
      });
    }
    return queryableLayers;
  }

  /** update overview map*/
  updateOverviewMap() {
    if (this.overViewMapControl) {
      var layers;
      if (this.situationMapLayers &amp;&amp; (this.situationMapLayers.length &gt; 0)) {
        layers &#x3D; this.situationMapLayers;
      } else {
        layers &#x3D; this.baseLayers;
      }
      if (this.overViewMapControl) {
        for (var i &#x3D; 0, iLen:number &#x3D; 
          this.overViewMapControl.getOverviewMap().getLayers().getLength(); i &lt; iLen; i++) {
          this.overViewMapControl.getOverviewMap().removeLayer(
            this.overViewMapControl.getOverviewMap().getLayers().item(0)
          );
        }
        if (layers) {
          for (var i &#x3D; 0, iLen:number &#x3D; 
            layers.length; i &lt; iLen; i++) {
            //Remove all layers but the base ones
            this.overViewMapControl.getOverviewMap().addLayer(layers[i]);
          }
        }
      }
    }
  }
  
  /** unsubscribe to component events*/
  unsubscribeMapConfigurationManager() {
    this.layerSubscription.unsubscribe();
    this.layerConfigurationSubscription.unsubscribe();
    this.baseLayersSubscription.unsubscribe();
    this.addLayersSubscription.unsubscribe();
    this.removeLayersSubscription.unsubscribe();
    this.situationMapConfigurationSubscription.unsubscribe();
    this.mapOptionsConfigurationSubscription.unsubscribe();
  }

  /** component destroy handler*/
  ngOnDestroy(): void {
    this.unsubscribeMapConfigurationManager();
  }
  
  /** init proj4 for coordinate transformation*/
  initProj4js() {
    // mercator
    proj4.defs(&quot;EPSG:54004&quot;, &quot;+title&#x3D;world mercator EPSG:54004 +proj&#x3D;merc +lat_ts&#x3D;0 +lon_0&#x3D;0 +k&#x3D;1 +x_0&#x3D;0 +y_0&#x3D;0 +ellps&#x3D;WGS84 +datum&#x3D;WGS84 +units&#x3D;m +no_defs&quot;);
    /*var projection &#x3D; new ol.proj.Projection({
      code: &quot;EPSG:54004&quot;,
      units: &quot;m&quot;
    });
    ol.proj.addProjection(projection);
    */
    // ed50 / UTM
    proj4.defs(&quot;EPSG:23029&quot;, &quot;+title&#x3D;ED50 / UTM zone 29N  +proj&#x3D;utm +zone&#x3D;29 +ellps&#x3D;intl +units&#x3D;m +no_defs&quot;);
    /*
    projection &#x3D; new ol.proj.Projection({
      code: &quot;EPSG:23029&quot;,
      units: &quot;m&quot;
    });
    ol.proj.addProjection(projection);
    */
    proj4.defs(&quot;EPSG:23030&quot;, &quot;+title&#x3D;ED50 / UTM zone 30N  +proj&#x3D;utm +zone&#x3D;30 +ellps&#x3D;intl +units&#x3D;m +no_defs&quot;);
    /*
    projection &#x3D; new ol.proj.Projection({
      code: &quot;EPSG:23030&quot;,
      units: &quot;m&quot;
    });
    ol.proj.addProjection(projection);
    */
    proj4.defs(&quot;EPSG:23031&quot;, &quot;+title&#x3D;ED50 / UTM zone 31N  +proj&#x3D;utm +zone&#x3D;31 +ellps&#x3D;intl +units&#x3D;m +no_defs&quot;);
    /*
    projection &#x3D; new ol.proj.Projection({
      code: &quot;EPSG:23031&quot;,
      units: &quot;m&quot;
    });
    ol.proj.addProjection(projection);
    */
    proj4.defs(&quot;EPSG:23032&quot;, &quot;+title&#x3D;ED50 / UTM zone 32N  +proj&#x3D;utm +zone&#x3D;32 +ellps&#x3D;intl +units&#x3D;m +no_defs&quot;);
    /*
    projection &#x3D; new ol.proj.Projection({
      code: &quot;EPSG:23032&quot;,
      units: &quot;m&quot;
    });
    ol.proj.addProjection(projection);
    */
    // ETRS89 / UTM
    proj4.defs(&quot;EPSG:25829&quot;, &quot;+proj&#x3D;utm +zone&#x3D;29 +ellps&#x3D;GRS80 +units&#x3D;m +no_defs&quot;);
    /*
    projection &#x3D; new ol.proj.Projection({
      code: &quot;EPSG:25829&quot;,
      units: &quot;m&quot;
    });
    ol.proj.addProjection(projection);
    */
    proj4.defs(&quot;EPSG:25830&quot;, &quot;+proj&#x3D;utm +zone&#x3D;30 +ellps&#x3D;GRS80 +units&#x3D;m +no_defs&quot;);
    /*
    projection &#x3D; new ol.proj.Projection({
      code: &quot;EPSG:25830&quot;,
      units: &quot;m&quot;
    });
    ol.proj.addProjection(projection);
    */
    proj4.defs(&quot;EPSG:25831&quot;, &quot;+proj&#x3D;utm +zone&#x3D;31 +ellps&#x3D;GRS80 +units&#x3D;m +no_defs&quot;);
                //&#x27;+proj&#x3D;utm +zone&#x3D;31 +ellps&#x3D;GRS80 +towgs84&#x3D;0,0,0,0,0,0,0 +units&#x3D;m +no_defs&#x27;
    /*
    projection &#x3D; new ol.proj.Projection({
      code: &quot;EPSG:25831&quot;,
      units: &quot;m&quot;
    });
    ol.proj.addProjection(projection);
    */
    proj4.defs(&quot;EPSG:25832&quot;, &quot;+proj&#x3D;utm +zone&#x3D;32 +ellps&#x3D;GRS80 +units&#x3D;m +no_defs&quot;);
    /*
    projection &#x3D; new ol.proj.Projection({
      code: &quot;EPSG:25832&quot;,
      units: &quot;m&quot;
    });
    ol.proj.addProjection(projection);
	  */
    // WGS84 / UTM
    proj4.defs(&quot;EPSG:32629&quot;, &quot;+proj&#x3D;utm +zone&#x3D;29 +ellps&#x3D;WGS84 +datum&#x3D;WGS84 +units&#x3D;m +no_defs &quot;);
    /*
    projection &#x3D; new ol.proj.Projection({
      code: &quot;EPSG:32629&quot;,
      units: &quot;m&quot;
    });
    ol.proj.addProjection(projection);
    */
    proj4.defs(&quot;EPSG:32630&quot;, &quot;+proj&#x3D;utm +zone&#x3D;30 +ellps&#x3D;WGS84 +datum&#x3D;WGS84 +units&#x3D;m +no_defs &quot;);
    /*
    projection &#x3D; new ol.proj.Projection({
      code: &quot;EPSG:32630&quot;,
      units: &quot;m&quot;
    });
    ol.proj.addProjection(projection);
    */
    proj4.defs(&quot;EPSG:32631&quot;, &quot;+proj&#x3D;utm +zone&#x3D;31 +ellps&#x3D;WGS84 +datum&#x3D;WGS84 +units&#x3D;m +no_defs &quot;);
    /*
    projection &#x3D; new ol.proj.Projection({
      code: &quot;EPSG:32631&quot;,
      units: &quot;m&quot;
    });
    ol.proj.addProjection(projection);
    */
    proj4.defs(&quot;EPSG:32632&quot;, &quot;+proj&#x3D;utm +zone&#x3D;32 +ellps&#x3D;WGS84 +datum&#x3D;WGS84 +units&#x3D;m +no_defs &quot;);
    /*
    projection &#x3D; new ol.proj.Projection({
      code: &quot;EPSG:32632&quot;,
      units: &quot;m&quot;
    });
    ol.proj.addProjection(projection);
	  */
	
    // geographic
    proj4.defs(&quot;EPSG:4326&quot;, &quot;+proj&#x3D;longlat +ellps&#x3D;WGS84 +datum&#x3D;WGS84 +no_defs &quot;);// wgs84
    /*
    projection &#x3D; new ol.proj.Projection({
      code: &quot;EPSG:4326&quot;,
      units: &quot;degrees&quot;
    });
    ol.proj.addProjection(projection);
    */
    proj4.defs(&quot;EPSG:4230&quot;, &quot;+proj&#x3D;longlat +ellps&#x3D;intl +no_defs&quot;);// ed50
    /*
    projection &#x3D; new ol.proj.Projection({
      code: &quot;EPSG:4230&quot;,
      units: &quot;degrees&quot;
    });
    ol.proj.addProjection(projection);
    */
    proj4.defs(&quot;EPSG:4258&quot;, &quot;+proj&#x3D;longlat +ellps&#x3D;GRS80 +no_defs&quot;);// etrs89
    /*
    projection &#x3D; new ol.proj.Projection({
      code: &quot;EPSG:4258&quot;,
      units: &quot;degrees&quot;
    });
    ol.proj.addProjection(projection);
    */
  }
  
  /** overview map control*/
  overViewMapControl:ol.control.OverviewMap;
    
  /** measurement control*/
  measurementToolControl;
    
  /** scale line tool control*/
  scaleLineToolControl;
    
  /** attribution tool control*/
  attributionToolControl;  
  
  /** zoom control*/
  zoomToolControl;
  
  /** location tool control*/
  locationToolControl;
  
  /** component init handler*/
  ngOnInit() {

    if (this.getMap() !&#x3D; null) {
      //The map is already created do nothing
      return;
    }

    // Initialize projections
    this.initProj4js();

    //Retrieve info from input parameters
    if ((this.initialLat !&#x3D; null) &amp;&amp; (this.initialLat !&#x3D; undefined) ||
        (this.initialLon !&#x3D; null) &amp;&amp; (this.initialLon !&#x3D; undefined) ||
        (this.initialProjection !&#x3D; null) &amp;&amp; (this.initialProjection !&#x3D; undefined) ||
        (this.initialZoom !&#x3D; null) &amp;&amp; (this.initialZoom !&#x3D; undefined)) {
        this.mapOptions &#x3D; new MapOptions();
        if ((this.initialLat !&#x3D; null) &amp;&amp; (this.initialLat !&#x3D; undefined)) {
          try {
            this.mapOptions.lat &#x3D; parseFloat(this.initialLat);
          } catch (e) {
            this.mapOptions.lat &#x3D; null;
          }
        }
        if ((this.initialLon !&#x3D; null) &amp;&amp; (this.initialLon !&#x3D; undefined)) {
          try {
            this.mapOptions.lon &#x3D; parseFloat(this.initialLon);
          } catch (e) {
            this.mapOptions.lon &#x3D; null;
          }
        }
        if ((this.initialProjection !&#x3D; null) &amp;&amp; (this.initialProjection !&#x3D; undefined)) {
          this.mapOptions.projection &#x3D; this.initialProjection;
        }
        if ((this.initialZoom !&#x3D; null) &amp;&amp; (this.initialZoom !&#x3D; undefined)) {
          try {
            this.mapOptions.zoom &#x3D; parseInt(this.initialZoom);
          } catch (e) {
            this.mapOptions.zoom &#x3D; null;
          }
        }
    }

    //Load a default map configuration (projection, zoom, center, max extent...)
    var mapConfig &#x3D; this.getDefaultMapConfiguration();

    var initialZoom: number &#x3D; 0;
    var initialCenter: ol.Coordinate;

    if (mapConfig) {
      //Initialize map configuration

      if ((mapConfig.initialZoom !&#x3D; null) &amp;&amp; (mapConfig.initialZoom !&#x3D; undefined)) {
        initialZoom &#x3D; mapConfig.initialZoom;
      }

      if (mapConfig.mapProjection) {
        this.projection &#x3D; mapConfig.mapProjection;
      }

      if ((mapConfig.initialLat !&#x3D; null) &amp;&amp; (mapConfig.initialLat !&#x3D; undefined) &amp;&amp; 
          (mapConfig.initialLon !&#x3D; null) &amp;&amp; (mapConfig.initialLon !&#x3D; undefined)) {
        initialCenter &#x3D; [mapConfig.initialLon, mapConfig.initialLat];

        if ((mapConfig.initialProjection !&#x3D; null) &amp;&amp; (mapConfig.initialProjection !&#x3D; undefined) &amp;&amp; 
            (mapConfig.initialProjection !&#x3D; this.projection)) {
            var projectionTo &#x3D; new ol.proj.Projection({
              code: this.projection
            });
            var projectionFrom &#x3D; new ol.proj.Projection({
              code: mapConfig.initialProjection
            });
            ol.proj.transform(initialCenter, projectionFrom, projectionTo);
        }
      }
      if (mapConfig.mapUnits) {
        this.units &#x3D; mapConfig.mapUnits;
      }

      if (mapConfig.tileHeight) {
        this.tileHeight &#x3D; mapConfig.tileHeight;
      }

      if (mapConfig.tileWidth) {
        this.tileWidth &#x3D; mapConfig.tileWidth;
      }

      if (mapConfig.mapMaxExtent) {
        this.maxExtent &#x3D; mapConfig.mapMaxExtent;
      }

      if (mapConfig.mapResolutions) {
        this.resolutions &#x3D; mapConfig.mapResolutions;
      }

      if (mapConfig.mapMaxScale) {
        this.maxScale &#x3D; mapConfig.mapMaxScale;
      }

      if (mapConfig.mapMinScale) {
        this.minScale &#x3D; mapConfig.mapMinScale;
      }

    }

    if ((this.mapOptions !&#x3D; undefined) &amp;&amp; (this.mapOptions !&#x3D; null)) {
      if ((this.mapOptions.zoom !&#x3D; undefined) &amp;&amp; (this.mapOptions.zoom !&#x3D; null)) {
        initialZoom &#x3D; this.mapOptions.zoom;
      }

      if ((this.mapOptions.lon !&#x3D; undefined) &amp;&amp; (this.mapOptions.lat !&#x3D; undefined) &amp;&amp; 
          (this.mapOptions.lon !&#x3D; null) &amp;&amp; (this.mapOptions.lat !&#x3D; null)) {
        initialCenter &#x3D; [this.mapOptions.lon, this.mapOptions.lat];

        if ((this.mapOptions.projection !&#x3D; undefined) &amp;&amp; (this.mapOptions.projection !&#x3D; undefined) &amp;&amp; 
        (this.mapOptions.projection !&#x3D; this.projection)) {
          var projectionTo &#x3D; new ol.proj.Projection({
              code: this.projection
            });
          var projectionFrom &#x3D; new ol.proj.Projection({
            code: this.mapOptions.projection
          });
          ol.proj.transform(initialCenter, projectionFrom, projectionTo);
        }
      }
    }

    ////////////////////////////////
    // Custom control declaration //
    ////////////////////////////////

    /** check supported events */
    var isEventSupported &#x3D; (function(){
      var TAGNAMES &#x3D; {
        &#x27;select&#x27;:&#x27;input&#x27;,&#x27;change&#x27;:&#x27;input&#x27;,
        &#x27;submit&#x27;:&#x27;form&#x27;,&#x27;reset&#x27;:&#x27;form&#x27;,
        &#x27;error&#x27;:&#x27;img&#x27;,&#x27;load&#x27;:&#x27;img&#x27;,&#x27;abort&#x27;:&#x27;img&#x27;
      }
      function isEventSupported(eventName) {
        var el &#x3D; document.createElement(TAGNAMES[eventName] || &#x27;div&#x27;);
        eventName &#x3D; &#x27;on&#x27; + eventName;
        var isSupported &#x3D; (eventName in el);
        if (!isSupported) {
          el.setAttribute(eventName, &#x27;return;&#x27;);
          isSupported &#x3D; typeof el[eventName] &#x3D;&#x3D; &#x27;function&#x27;;
        }
        el &#x3D; null;
        return isSupported;
      }
      return isEventSupported;
    })();

    /** Custom Loading control*/
    class LoadingControl extends ol.control.Control{
      element;
      loading;
      loaded;
      progress;
      
      /**
       * Renders a progress bar.
       */
      constructor(opt_options) {  
            var options &#x3D; opt_options || {};
            
            var element &#x3D; document.createElement(&quot;DIV&quot;);
            element.className &#x3D; (options.progress?&quot;ol-progress&quot;:&quot;ol-loading&quot;) + 
            &quot; ol-unselectable ol-control&quot;;

            super({
              element: element,
              target: options.target
            });

            this.progress &#x3D; this.progress || options.progress;
            
            this.loading &#x3D; 0;
            this.loaded &#x3D; 0;

            this.hide();
      }


      /**
       * Increment the count of loading tiles.
       */
      addLoading() {
        if (this.loading &#x3D;&#x3D;&#x3D; 0) {
          this.show();
        }
        ++this.loading;
        this.update();
      };


      /**
       * Increment the count of loaded tiles.
       */
      addLoaded() {
        if (this.progress) {
          var this_ &#x3D; this;
          setTimeout(function() {
            ++this_.loaded;
            this_.update();
          }, 100);
        } else {
          ++this.loaded;
            this.update();
        }
      };


      /**
       * Update the progress bar.
       * constructor
       */
      update() {
        if (this.progress) {
          var width &#x3D; (this.loaded / this.loading * 100).toFixed(1) + &#x27;%&#x27;;
          this.element.style.width &#x3D; width;
          if (this.loading &#x3D;&#x3D;&#x3D; this.loaded) {
            this.loading &#x3D; 0;
            this.loaded &#x3D; 0;
            var this_ &#x3D; this;
            setTimeout(function() {
            this_.hide();
            }, 500);
          }
        } else {
          if (this.loading &#x3D;&#x3D;&#x3D; this.loaded) {
            this.loading &#x3D; 0;
            this.loaded &#x3D; 0;
            this.hide();
          }
        }
      };


      /**
       * Show the progress bar.
       */
      show() {
        this.element.style.visibility &#x3D; &#x27;visible&#x27;;
      };


      /**
       * Hide the progress bar.
       */
      hide(force?:boolean) {
        force &#x3D; ((force !&#x3D; null) &amp;&amp; (force !&#x3D; undefined))?force:false;
        if ((this.loading &#x3D;&#x3D;&#x3D; this.loaded) || force) {
          //Avoid having negative counters
          this.loading &#x3D; 0;
          this.loaded &#x3D; 0;
          this.element.style.visibility &#x3D; &#x27;hidden&#x27;;
          if (this.progress) {
            this.element.style.width &#x3D; 0;
          }
        }
      };

      /**
       * Reset the counters and hide the loading view.
       */
      reset() {
        this.hide(true);
      }
    }
    
    /** Custom base layer selector control*/
    class SelectBaseLayerControl extends ol.control.Control{

      groupNames;
      layerGroups;
      layers;

      selectedGroup: number;

      dialog: MatDialog;
      selectionDialogRef: MatDialogRef&lt;LayerSelectionDialogComponent&gt;;
      toolContainer;

      button;

      /** set dialog*/
      setDialog(dialog: MatDialog) {
        this.dialog &#x3D; dialog;
      }

      /** on data chenged handler*/
      onDataChanged(data) {
        if (data.layerGroups) {
          this.layerGroups &#x3D; data.layerGroups;
        }
        if (data.layers) {
          this.layers &#x3D; data.layers;
        }

        if ((this.layerGroups &amp;&amp; (this.layerGroups.length &gt; 0)) &amp;&amp; 
            (this.layers &amp;&amp; (this.layers.length &gt; 0))) {
          //Show the first on the list
          if (data.groupNames) {
            this.groupNames &#x3D; data.groupNames;
          } else {
            this.groupNames &#x3D; [];
            for (var i &#x3D; 0, iLen &#x3D; this.layerGroups.length; i &lt; iLen; i++) {
              this.groupNames.push(this.layerGroups[i].name);
            }
          }
          if ((data.selection !&#x3D; undefined) &amp;&amp; 
              (data.selection !&#x3D; null)) {
            this.selectedGroup &#x3D; data.selection;
          } else {
            this.selectedGroup &#x3D; 0;
          }
        } else {
          this.selectedGroup &#x3D; -1
        }
        //Reload
        this.selectLayerGroup(this.selectedGroup);
      }

      showSelectionDialog() {
        if ((this.dialog !&#x3D; null) &amp;&amp; (this.dialog !&#x3D; undefined)) {
          const dialogConfig &#x3D; new MatDialogConfig();

          dialogConfig.disableClose &#x3D; true;
          dialogConfig.autoFocus &#x3D; true;
          dialogConfig.hasBackdrop &#x3D; true;

          var data &#x3D; new LayerSelectionDialogData();

          data.selected &#x3D; this.selectedGroup;
          data.itemList &#x3D; this.groupNames;

          dialogConfig.data &#x3D; data;

          var this_ &#x3D; this;

          this.selectionDialogRef &#x3D; this.dialog.open(LayerSelectionDialogComponent, dialogConfig);
          this.selectionDialogRef.afterClosed().subscribe(
            data &#x3D;&gt; {
                try {
                  for (var i &#x3D; 0, iLen &#x3D; this.layerGroups.length; i &lt; iLen; i++) {
                    if (data[this.layerGroups[i].name]) {
                      this_.selectLayerGroup(i);
                      break;
                    }
                  }
                } catch (e) {
                  //
                }
            }
          );
        }
      }

      constructor(opt_options) {  
        var options &#x3D; opt_options || {};

        var element &#x3D; document.createElement(&quot;DIV&quot;);
        element.className &#x3D; &quot;ol-change-baselayer ol-unselectable ol-control&quot;
        //initially hidden
        element.style.display &#x3D; &quot;none&quot;;
        element.style.visibility &#x3D; &quot;hidden&quot;;

        super({
          element: element,
          target: options.target
        });

        this.selectedGroup &#x3D; -1;

        var this_ &#x3D; this;

        var controlBtn &#x3D; document.createElement(&quot;BUTTON&quot;); 
        if ((options.tooltip !&#x3D; null) &amp;&amp; (options.tooltip !&#x3D; null)) {
          controlBtn.title &#x3D; options.tooltip;
        }

        controlBtn.setAttribute(&quot;type&quot;, &quot;button&quot;);
        controlBtn.id&#x3D;&quot;map-layer-selector-btn&quot;;
        controlBtn.className &#x3D; &quot;mat-raised-button&quot;;
        var icon &#x3D; document.createElement(&#x27;i&#x27;);
        icon.className&#x3D;&quot;material-icons&quot;;
        icon.innerHTML&#x3D;&quot;layers&quot;;
        controlBtn.appendChild(icon);
        element.appendChild(controlBtn);
        if (isEventSupported(&#x27;touchstart&#x27;)) {
          controlBtn.addEventListener(&#x27;touchstart&#x27;, function() {  
                this_.showSelectionDialog();
              }, false);
        } else {
          controlBtn.addEventListener(&#x27;click&#x27;, function() {  
                this_.showSelectionDialog();
              }, false);
        }

        this.button &#x3D; controlBtn;

        this.toolContainer &#x3D; element;            

        this.onDataChanged({
          layerGroups: options.layerGroups,
          layers: options.layers,
          selection: options.selection
        });
      }

      hideControlButton() {
        if (this.toolContainer) {
          this.toolContainer.style.display &#x3D; &quot;none&quot;;
          this.toolContainer.style.visibility &#x3D; &quot;hidden&quot;;
          //TODO Notify control hidden
        }
      }

      showControlButton() {
        if (this.toolContainer) {
          this.toolContainer.style.display &#x3D; &quot;&quot;;
          this.toolContainer.style.visibility &#x3D; &quot;visible&quot;;          
          //TODO Notify control shown
        }
      }

      selectLayerGroup(value) {
        if (value &lt; 0) {
          this.hideControlButton();
        } else {
          if (this.layerGroups &amp;&amp; this.layerGroups.length &gt; 1) {
            this.showControlButton();
          } else {
            this.hideControlButton();
          }
          var layerList &#x3D; this.layerGroups[value].memberPositions;
          if ((layerList &#x3D;&#x3D; null) || (layerList &#x3D;&#x3D; undefined) || (this.layers &#x3D;&#x3D; null) || 
              (this.layers &#x3D;&#x3D; undefined)) {
            //No information for the requested type return
            //TODO raise error if needed be
            return;
          }
          this.selectedGroup &#x3D; value;
          var layerName;
          var layerId;
          for (var i &#x3D; 0, iLen &#x3D; this.layers.length; i &lt; iLen; i++) {
            layerName &#x3D; this.layers[i].getProperties()[&quot;serverName&quot;] || &quot;&quot;;
            layerId &#x3D; this.layers[i].getProperties()[&quot;id&quot;] || &quot;&quot;;
            this.layers[i].setVisible(layerList.indexOf(i) !&#x3D; -1);
          }
        }
      }

      updateTooltip(tooltip) {
        if (this.button) {
          this.button.title &#x3D; tooltip;
        }
      }
    }

    /** Custom geolocation control*/
    class GeolocationControl extends ol.control.Control{
      geolocation: ol.Geolocation;

      geolocationLayer: ol.layer.Vector;

      button;

      constructor(opt_options) {  
        var options &#x3D; opt_options || {};

        var icon &#x3D; document.createElement(&#x27;i&#x27;);
        icon.className&#x3D;&quot;material-icons&quot;;
        icon.innerHTML&#x3D;&quot;my_location&quot;;

        var button &#x3D; document.createElement(&#x27;button&#x27;);
        button.setAttribute(&quot;type&quot;, &quot;button&quot;);
        if (options.geolocationTooltip) {
          button.title &#x3D; options.geolocationTooltip;
        }
        button.className&#x3D;&quot;mat-raised-button&quot;;
        button.appendChild(icon);

        var element &#x3D; document.createElement(&#x27;div&#x27;);
        element.className &#x3D; &#x27;geolocation-btn ol-unselectable ol-control&#x27;;
        element.appendChild(button);

        super({
          element: element,
          target: options.target
        });

        this.button &#x3D; button;

        var this_ &#x3D; this;

        function setGeolocationActive(active) {
          if (active) {
            this_.geolocation.setTracking(true);   
            button.setAttribute(&quot;active&quot;, &quot;true&quot;);
            button.className +&#x3D; &quot; geolocation-active&quot;
            icon.innerHTML &#x3D; &quot;my_location&quot;;
          } else {
            this_.geolocation.setTracking(false);          
            button.setAttribute(&quot;active&quot;, &quot;false&quot;);
            button.className &#x3D; button.className.replace(&quot; geolocation-active&quot;, &quot;&quot;);
            icon.innerHTML &#x3D; &quot;my_location&quot;;
          }
    
          if (this_.geolocationLayer !&#x3D; null) {
            this_.geolocationLayer.setVisible(active);
            try {
              this_.geolocationLayer.getSource().getFeatures()[0].setStyle(active?getPositionStyle():null);
            } catch (ex) {
              //
            }
          }
        }

        function getPositionStyle() {
          return new ol.style.Style({
            image: new ol.style.Icon({
              src:locationImg
            })
          });
        }

        var requestLocation &#x3D; function() {
          if (this_.geolocation &#x3D;&#x3D; null) {
            // Geolocation feature
            this_.geolocation &#x3D; new ol.Geolocation({
              projection: this_.getMap().getView().getProjection()
            });
    
            this_.geolocation.on(&#x27;change&#x27;, function(evt) {
              //Update information
            });
            this_.geolocation.on(&#x27;error&#x27;, function(evt) {
              setGeolocationActive(false);
            });
    
            // GeoLocation accuracy
            /*var accuracyFeature &#x3D; new ol.Feature();
            this_.geolocation.on(&#x27;change:accuracyGeometry&#x27;, function() {
              accuracyFeature.setGeometry(this_.geolocation.getAccuracyGeometry());
            });*/
    
            // User position
            var positionFeature &#x3D; new ol.Feature();
            positionFeature.setStyle(getPositionStyle());
            this_.geolocation.on(&#x27;change:position&#x27;, function(evt) {
              var coordinates &#x3D; this_.geolocation.getPosition();
              positionFeature.setGeometry(coordinates ?
                new ol.geom.Point(coordinates) : null);
            });
    
            //Add vector layer
            this_.geolocationLayer &#x3D; new ol.layer.Vector({
              map: this_.getMap(),
              source: new ol.source.Vector({
                features: [/*accuracyFeature, */positionFeature]
              })
            });
          }
          if (button.getAttribute(&quot;active&quot;) &#x3D;&#x3D; &quot;true&quot;) {
            setGeolocationActive(false);
          } else {
            setGeolocationActive(true);
          }
        };
        if (isEventSupported(&#x27;touchstart&#x27;)) {
          button.addEventListener(&#x27;touchstart&#x27;, requestLocation, false);
        } else {
          button.addEventListener(&#x27;click&#x27;, requestLocation, false);
        }
      }

      updateTooltip(title) {
        if (this.button) {
          this.button.title &#x3D; title;
        }
      }
    };

    /** Custom measurement control*/
    class MeasurementControl extends ol.control.Control{

      /**
       * Layer to draw features.
       */
      vector:ol.layer.Vector;

      /**
       * Layer to draw features.
       */
      source:ol.source.Vector;

      /**
       * Currently drawn feature.
       */
      sketch:ol.Feature;
      /**
       * The help tooltip element.
       */
      helpTooltipElement:Element;
      /**
       * Overlay to show the help messages.
       */
      helpTooltip:ol.Overlay;
      /**
       * The measure tooltip element.
       */
      measureTooltipElement:Element;
      /**
       * Overlay to show the measurement.
       */
      measureTooltip:ol.Overlay;

      /**
       * Message to show when the user is drawing a polygon.
       */
      continuePolygonMsg:string;

      /**
       * Message to show when the user is drawing a line.
       */
      continueLineMsg:string;

      /**
       * Interaction to draw measurement
       */
      draw:ol.interaction.Draw;

      /**
       * Feature style colors
       */
      strokeFinishedColorStyle:string;
      strokeMeasuringColorStyle:string;
      strokeImageMeasuringColorStyle:string;
      backgroundColorStyle:string;

      /**
       * Overlay tooltip counter
       */
      overlayCount:number;

      /**
       * Control buttons
       */
      buttonLength:HTMLElement;
      buttonArea:HTMLElement;

      /**
       * Map
       */
      map:ol.Map;

      /**
       * Handle pointer move.
       */
      pointerMoveHandler;
      /**
       * Handle mouse out.
       */
      mouseOutHandler;

      lengthSelected:boolean;
      areaSelected:boolean;

      updateMessages(messages) {
        if (this.buttonLength) {
          this.buttonLength.title &#x3D; messages.lengthTooltip;
        }

        if (this.buttonArea) {
          this.buttonArea.title &#x3D; messages.areaTooltip;
        }

        this.continueLineMsg &#x3D; messages.continueLineMsg;
        this.continuePolygonMsg &#x3D; messages.continuePolygonMsg;

        if (this.areaSelected || this.lengthSelected) {
          if (this.helpTooltipElement) {
            this.helpTooltipElement.innerHTML &#x3D; 
              this.areaSelected?this.continuePolygonMsg:this.continueLineMsg;
          }
        }
      }

      constructor(opt_options) {
        var options &#x3D; opt_options || {};

        var element &#x3D; document.createElement(&quot;DIV&quot;);
        element.className &#x3D; &quot;ol-measurement ol-unselectable ol-control&quot;

        super({
          element: element,
          target: options.target
        });

        this.areaSelected &#x3D; false;
        this.lengthSelected &#x3D; false;

        this.overlayCount &#x3D; 0;

        this.source &#x3D; new ol.source.Vector();

        if (options.backgroundColorStyle) {
          this.backgroundColorStyle &#x3D; options.backgroundColorStyle;
        } else {
          this.backgroundColorStyle &#x3D; &quot;rgba(255, 255, 255, 0.2)&quot;;
        }

        if (options.strokeFinishedColorStyle) {
          this.strokeFinishedColorStyle &#x3D; options.strokeFinishedColorStyle;
        } else {
          this.strokeFinishedColorStyle &#x3D; &quot;rgba(163,38,56,1)&quot;;
        }

        if (options.strokeMeasuringColorStyle) {
          this.strokeMeasuringColorStyle &#x3D; options.strokeMeasuringColorStyle;
        } else {
          this.strokeMeasuringColorStyle &#x3D; &quot;rgba(0, 0, 0, 0.5)&quot;;
        }

        if (options.strokeImageMeasuringColorStyle) {
          this.strokeImageMeasuringColorStyle &#x3D; options.strokeImageMeasuringColorStyle;
        } else {
          this.strokeImageMeasuringColorStyle &#x3D; &quot;rgba(0, 0, 0, 0.7)&quot;;
        }

        this.vector &#x3D; new ol.layer.Vector({
          source: this.source,
          style: new ol.style.Style({
            fill: new ol.style.Fill({
              color: this.backgroundColorStyle
            }),
            stroke: new ol.style.Stroke({
              color: this.strokeFinishedColorStyle,
              width: 2
            }),
            image: new ol.style.Circle({
              radius: 7,
              fill: new ol.style.Fill({
                color: this.strokeFinishedColorStyle
              })
            })
          }),
          visible:false
        });

        var this_ &#x3D; this;

        //Create control buttons
        function activate() {

          //get tool status
          let active:boolean &#x3D; this.getAttribute(&quot;tool-active&quot;) &#x3D;&#x3D; &quot;true&quot;;

          //get tool type
          let toolType:string &#x3D; this.getAttribute(&quot;tool-type&quot;);

          if (!active) {
            this_.onActivate(toolType);
          } else {
            this_.onDeactivate(toolType);
          }
        }

        //Length measurement
        var icon &#x3D; document.createElement(&#x27;i&#x27;);
        icon.className&#x3D;&quot;material-icons&quot;;
        icon.innerHTML&#x3D;&quot;straighten&quot;;

        this.buttonLength &#x3D; document.createElement(&#x27;button&#x27;);
        this.buttonLength.setAttribute(&quot;type&quot;, &quot;button&quot;);
        this.buttonLength.setAttribute(&quot;tool-type&quot;, &quot;length&quot;);
        this.buttonLength.setAttribute(&quot;tool-active&quot;, &quot;false&quot;);
        if (options.lengthTooltip) {
          this.buttonLength.title &#x3D; options.lengthTooltip;
        }
        this.buttonLength.className&#x3D;&quot;mat-raised-button measurement-length&quot;;
        this.buttonLength.appendChild(icon);
        element.appendChild(this.buttonLength);
        if (isEventSupported(&#x27;touchstart&#x27;)) {
          this.buttonLength.addEventListener(&#x27;touchstart&#x27;, activate, false);
        } else {
          this.buttonLength.addEventListener(&#x27;click&#x27;, activate, false);
        }

        //Area measurement
        icon &#x3D; document.createElement(&#x27;i&#x27;);
        icon.className&#x3D;&quot;material-icons&quot;;
        icon.innerHTML&#x3D;&quot;border_outer&quot;;

        this.buttonArea &#x3D; document.createElement(&#x27;button&#x27;);
        this.buttonArea.setAttribute(&quot;type&quot;, &quot;button&quot;);
        this.buttonArea.setAttribute(&quot;tool-type&quot;, &quot;area&quot;);
        this.buttonArea.setAttribute(&quot;tool-active&quot;, &quot;false&quot;);
        if (options.areaTooltip) {
          this.buttonArea.title &#x3D; options.areaTooltip;
        }
        this.buttonArea.className&#x3D;&quot;mat-raised-button measurement-area&quot;;
        this.buttonArea.appendChild(icon);
        element.appendChild(this.buttonArea);
        if (isEventSupported(&#x27;touchstart&#x27;)) {
          this.buttonArea.addEventListener(&#x27;touchstart&#x27;, activate, false);
        } else {
          this.buttonArea.addEventListener(&#x27;click&#x27;, activate, false);
        }

        if (options.continuePolygonMsg) {
          this.continuePolygonMsg &#x3D; options.continuePolygonMsg;
        }

        if (options.continueLineMsg) {
          this.continueLineMsg &#x3D; options.continueLineMsg;
        }

        if (options.drawHelpTooltip) {
          this.pointerMoveHandler &#x3D; function (evt) {
            if (evt.dragging) {
              return;
            }

            var helpMsg &#x3D; &#x27;Click to start drawing&#x27;;

            if (this_.sketch) {
              var geom &#x3D; (this_.sketch.getGeometry());
              if (geom instanceof ol.geom.Polygon) {
                if (this_.continuePolygonMsg !&#x3D; null) {
                  helpMsg &#x3D; this_.continuePolygonMsg;
                }
              } else if (geom instanceof ol.geom.LineString) {
                if (this_.continueLineMsg !&#x3D; null) {
                  helpMsg &#x3D; this_.continueLineMsg;
                }
              }
            }

            if (this_.helpTooltipElement) {
              this_.helpTooltipElement.innerHTML &#x3D; helpMsg;
              this_.helpTooltip.setPosition(evt.coordinate);
              this_.helpTooltipElement.classList.remove(&#x27;hidden&#x27;);
            }
          };
          
          this.mouseOutHandler &#x3D; function (evt) {
            if (this_.helpTooltipElement) {
              this_.helpTooltipElement.classList.add(&#x27;hidden&#x27;);
            }
          };
        }

      }

      setMap(map: ol.Map) {
        super.setMap(map);
        this.map &#x3D; this.getMap();
        this.map.addLayer(this.vector);
        var control &#x3D; this;
        this.map.on(&quot;layersadded&quot;, function(){
          //Update index
          control.map.removeLayer(control.vector);
          control.map.addLayer(control.vector);
        });
      }

      clearTooltips() {
        if (this.overlayCount &gt; 0) {
          if (this.map.getOverlays().getLength() &gt; 0) {
            let overlays &#x3D; this.map.getOverlays();
            let overlay:ol.Overlay;
            for (var i &#x3D; 0, iLen &#x3D; this.overlayCount; i &lt; iLen; i++) {
              overlay &#x3D; this.map.getOverlayById(&quot;measurement-tooltip-&quot; + i);
              if (overlay !&#x3D; null) {
                this.map.removeOverlay(overlay);  
              }
            }
          }
        }
        this.overlayCount &#x3D; 0;
      }

      onActivate(typeSelected:string) {
        //Add event handling
        this.source.clear();
        this.clearTooltips();
        this.vector.setVisible(true);
        if (this.pointerMoveHandler !&#x3D; null) {
          this.map.on(&#x27;pointermove&#x27;, this.pointerMoveHandler);
        }
        if (this.mouseOutHandler !&#x3D; null) {
          this.map.getViewport().addEventListener(&#x27;mouseout&#x27;, this.mouseOutHandler);
        }
        this.selectMeasurementType(typeSelected);
        if (typeSelected &#x3D;&#x3D; &quot;area&quot;) {
          this.buttonArea.className +&#x3D; &quot; tool-active&quot;;
          this.buttonArea.setAttribute(&quot;tool-active&quot;, &quot;true&quot;);
          this.buttonLength.className &#x3D; 
            this.buttonLength.className.replace(&quot; tool-active&quot;, &quot;&quot;);
          this.buttonLength.setAttribute(&quot;tool-active&quot;, &quot;false&quot;);
          this.areaSelected &#x3D; true;
        } else {
          this.buttonLength.className +&#x3D; &quot; tool-active&quot;;
          this.buttonLength.setAttribute(&quot;tool-active&quot;, &quot;true&quot;);
          this.buttonArea.className  &#x3D; 
            this.buttonArea.className.replace(&quot; tool-active&quot;, &quot;&quot;);
          this.buttonArea.setAttribute(&quot;tool-active&quot;, &quot;false&quot;);
          this.lengthSelected &#x3D; true;
        }
      }

      onDeactivate(typeSelected:string) {
        //Remove event handling
        this.source.clear();
        this.clearTooltips();
        this.vector.setVisible(false);
        if (this.pointerMoveHandler !&#x3D; null) {
          this.map.un(&#x27;pointermove&#x27;,  this.pointerMoveHandler);
        }
        if (this.mouseOutHandler) {
          this.map.getViewport().removeEventListener(&#x27;mouseout&#x27;, this.mouseOutHandler);
        }
        this.removeDrawInteraction();
        if (typeSelected &#x3D;&#x3D; &quot;area&quot;) {
          this.buttonArea.className &#x3D; 
            this.buttonArea.className.replace(&quot; tool-active&quot;, &quot;&quot;);
          this.buttonArea.setAttribute(&quot;tool-active&quot;, &quot;false&quot;);
          this.areaSelected &#x3D; false;
        } else {
          this.buttonLength.className &#x3D; 
            this.buttonLength.className.replace(&quot; tool-active&quot;, &quot;&quot;);
          this.buttonLength.setAttribute(&quot;tool-active&quot;, &quot;false&quot;);
          this.lengthSelected &#x3D; false;
        }
      }

      /**
       * Format length output.
       */
      formatLength(line) {
        var length &#x3D; ol.Sphere.getLength(line);
        var output;
        if (length &gt; 100) {
          output &#x3D; (Math.round(length / 1000 * 100) / 100) +
              &#x27; &#x27; + &#x27;km&#x27;;
        } else {
          output &#x3D; (Math.round(length * 100) / 100) +
              &#x27; &#x27; + &#x27;m&#x27;;
        }
        return output;
      };

      /**
       * Format area output.
       */
      formatArea(polygon) {
        var area &#x3D; ol.Sphere.getArea(polygon);
        var output;
        if (area &gt; 10000) {
          output &#x3D; (Math.round(area / 1000000 * 100) / 100) +
              &#x27; &#x27; + &#x27;km&lt;sup&gt;2&lt;/sup&gt;&#x27;;
        } else {
          output &#x3D; (Math.round(area * 100) / 100) +
              &#x27; &#x27; + &#x27;m&lt;sup&gt;2&lt;/sup&gt;&#x27;;
        }
        return output;
      };

      removeDrawInteraction() {
        if (this.draw !&#x3D; null) {
          this.map.removeInteraction(this.draw);
          this.draw &#x3D; null;
        }
      }

      selectMeasurementType(typeSelected:string) {
        this.removeDrawInteraction();
        this.addInteraction(typeSelected);
      };

      addInteraction(typeSelected:string) {
        let type:ol.geom.GeometryType &#x3D; (typeSelected &#x3D;&#x3D; &#x27;area&#x27; ? &quot;Polygon&quot; : &quot;LineString&quot;);
        this.draw &#x3D; new ol.interaction.Draw({
          source: this.source,
          type: type,
          style: new ol.style.Style({
            fill: new ol.style.Fill({
              color: this.backgroundColorStyle
            }),
            stroke: new ol.style.Stroke({
              color: this.strokeMeasuringColorStyle,
              lineDash: [10, 10],
              width: 2
            }),
            image: new ol.style.Circle({
              radius: 5,
              stroke: new ol.style.Stroke({
                color: this.strokeImageMeasuringColorStyle
              }),
              fill: new ol.style.Fill({
                color: this.backgroundColorStyle
              })
            })
          })
        });
        this.map.addInteraction(this.draw);

        this.createMeasureTooltip();
        this.createHelpTooltip();

        var _self &#x3D; this;

        var listener;
        this.draw.on(&#x27;drawstart&#x27;,
          function(evt:any) {
            // set sketch
            _self.sketch &#x3D; evt.feature;
            let tooltipCoord:ol.Coordinate;
            if (evt.coordinate) {
              tooltipCoord &#x3D; evt.coordinate;
            }

            listener &#x3D; _self.sketch.getGeometry().on(&#x27;change&#x27;, function(evt) {
              var geom &#x3D; evt.target;
              var output;
              if (geom instanceof ol.geom.Polygon) {
                output &#x3D; _self.formatArea(geom);
                tooltipCoord &#x3D; geom.getInteriorPoint().getCoordinates();
              } else if (geom instanceof ol.geom.LineString) {
                output &#x3D; _self.formatLength(geom);
                tooltipCoord &#x3D; geom.getLastCoordinate();
              }
              _self.measureTooltipElement.innerHTML &#x3D; output;
              _self.measureTooltip.setPosition(tooltipCoord);
            });
          }, this);

        this.draw.on(&#x27;drawend&#x27;,
          function() {
            _self.measureTooltipElement.className &#x3D; &#x27;measurement-tooltip measurement-tooltip-static&#x27;;
            _self.measureTooltip.setOffset([0, -7]);
            // unset sketch
            _self.sketch &#x3D; null;
            // unset tooltip so that a new one can be created
            _self.measureTooltipElement &#x3D; null;
            _self.createMeasureTooltip();
            ol.Observable.unByKey(listener);
          }, this);
      }


      /**
       * Creates a new help tooltip
       */
      createHelpTooltip() {
        if (this.helpTooltipElement) {
          this.helpTooltipElement.parentNode.removeChild(this.helpTooltipElement);
        }
        this.helpTooltipElement &#x3D; document.createElement(&#x27;div&#x27;);
        this.helpTooltipElement.className &#x3D; &#x27;measurement-tooltip hidden&#x27;;
        this.helpTooltip &#x3D; new ol.Overlay({
          id: &quot;measurement-tooltip-&quot; + (this.overlayCount++),
          element: this.helpTooltipElement,
          offset: [15, 0],
          positioning: &#x27;center-left&#x27;
        });
        this.map.addOverlay(this.helpTooltip);
      }


      /**
       * Creates a new measure tooltip
       */
      createMeasureTooltip() {
        if (this.measureTooltipElement) {
          this.measureTooltipElement.parentNode.removeChild(this.measureTooltipElement);
        }
        this.measureTooltipElement &#x3D; document.createElement(&#x27;div&#x27;);
        this.measureTooltipElement.className &#x3D; &#x27;measurement-tooltip measurement-tooltip-measure&#x27;;
        this.measureTooltip &#x3D; new ol.Overlay({
          id: &quot;measurement-tooltip-&quot; + (this.overlayCount++),
          element: this.measureTooltipElement,
          offset: [0, -15],
          positioning: &#x27;bottom-center&#x27;
        });
        this.map.addOverlay(this.measureTooltip);
      }
    }

    const SCALE_BAR_UNITS &#x3D; {
      DEGREES: &#x27;degrees&#x27;,
      IMPERIAL: &#x27;imperial&#x27;,
      NAUTICAL: &#x27;nautical&#x27;,
      METRIC: &#x27;metric&#x27;,
      US: &#x27;us&#x27;
    };

    const SCALE_BAR_LEADING_DIGITS &#x3D; [1, 2, 5];

    const OL_PROJ_UNITS &#x3D; {
      DEGREES: &#x27;degrees&#x27;,
      FEET: &#x27;ft&#x27;,
      METERS: &#x27;m&#x27;,
      PIXELS: &#x27;pixels&#x27;,
      TILE_PIXELS: &#x27;tile-pixels&#x27;,
      USFEET: &#x27;us-ft&#x27;
    };

    //Custom scalebar control
    class ScaleBarControl extends ol.control.Control{
      
      innerElement_;
      element_;
      viewState_ ;
      minWidth_;
      renderedVisible_;
      renderedWidth_ ;
      renderedHTML_;
      units_;
      tooltipMessage;

      updateTooltip(tooltip) {
        this.tooltipMessage &#x3D; tooltip;
        this.update();
      }

      /**
       * constructor
       */
      constructor(opt_options?) {

        var options &#x3D; opt_options || {};

        var className &#x3D; options.className !&#x3D;&#x3D; undefined ? options.className : &#x27;ol-scale-line&#x27;;      
        var minWidth &#x3D; options.minWidth !&#x3D;&#x3D; undefined ? options.minWidth : 64;

        var innerElement &#x3D; document.createElement(&#x27;DIV&#x27;);
        innerElement.className &#x3D; className + &#x27;-inner&#x27;;      
        var element &#x3D; document.createElement(&#x27;DIV&#x27;);
        element.className &#x3D; className + &#x27; &#x27; + &#x27;ol-unselectable&#x27;;
        element.appendChild(innerElement);

        function render(mapEvent) {
          this.draw();
          if (!this.rendered) {
            this.rendered &#x3D; true;
            this.updateElement();
          }
        }
        
        super({
          element: element,
          render: options.render?options.render:render,
          target: options.target
        });

        this.displayClass &#x3D; options.displayClass?options.displayClass:&#x27;ol-scale-line-info-&#x27;;
        this.showTopBar &#x3D; options.showTopBar?options.showTopBar:true;
        this.showBottomBar &#x3D; options.showTopBar?options.showBottomBar:true;
        this.maxWidth &#x3D; options.maxWidth?options.maxWidth:100;

        this.tooltipMessage &#x3D; options.tooltipMessage?
          options.tooltipMessage:&quot;scale 1:&quot;;

        this.renderedVisible_ &#x3D; false;
        this.renderedWidth_ &#x3D; undefined;
        this.renderedHTML_ &#x3D; &#x27;&#x27;;

        this.minWidth_ &#x3D; minWidth;
        this.element_ &#x3D; element;
        this.innerElement_ &#x3D; innerElement;
        this.viewState_ &#x3D; null;

        this.topOutUnits &#x3D; &quot;km&quot;;
        this.topInUnits &#x3D; &quot;m&quot;;
        this.bottomOutUnits &#x3D; &quot;mi&quot;;
        this.bottomInUnits &#x3D; &quot;ft&quot;;
      
        this.setUnits((options.units) ||
                        SCALE_BAR_UNITS.METRIC);
      }

      setMap(map:ol.Map) {
        super.setMap(map);
        this.geodesic &#x3D; map.getView().getProjection().getCode() &#x3D;&#x3D; &quot;EPSG:900913&quot;;
        var this_ &#x3D; this;
        this.getMap().getView().on(&#x27;change:resolution&#x27;, function(evt){
          this_.updateElement();
        });
      }

      updateMap(map:ol.Map) {
        this.setMap(map);
        this.updateElement();
      }

      getValidUnits(units) {
        if (units &amp;&amp; (typeof units &#x3D;&#x3D; &quot;string&quot;)) {
          switch (units.toLowerCase()) {
            case SCALE_BAR_UNITS.DEGREES:
              return SCALE_BAR_UNITS.DEGREES;
            case SCALE_BAR_UNITS.IMPERIAL:
              return SCALE_BAR_UNITS.IMPERIAL;
            case SCALE_BAR_UNITS.NAUTICAL:
              return SCALE_BAR_UNITS.NAUTICAL;
              case SCALE_BAR_UNITS.US:
                return SCALE_BAR_UNITS.US;
            case SCALE_BAR_UNITS.METRIC:
            default:
              return SCALE_BAR_UNITS.METRIC;
          }
        }
        return SCALE_BAR_UNITS.METRIC;
      }

      setUnits(newUnits:string) {
        var newValidUnits &#x3D; this.getValidUnits(newUnits);
        if (newValidUnits !&#x3D; this.units_) {
          this.units_ &#x3D; newValidUnits;
          this.updateElement();
        }
      }

      getUnits() {
        return this.units_;
      }

      updateElement() {
        this.update();
      }

      formatNumber(num, dec?, tsep?, dsep?):string {
        dec &#x3D; (dec !&#x3D; undefined) ? dec : 0;
        tsep &#x3D; (tsep !&#x3D; undefined) ? tsep : &quot;,&quot;;
        dsep &#x3D; (dsep !&#x3D; undefined) ? dsep : &quot;.&quot;;

        var str;
        var integer &#x3D; Math.round(num).toString();
        var thousands &#x3D; /(-?[0-9]+)([0-9]{3})/;

        if(dec &gt; 0) {
            var rem &#x3D; Math.floor(Math.pow(10, dec) * (num - Math.round(num)));
            if(rem &#x3D;&#x3D; 0) {
                str &#x3D; integer;
            } else {
                str &#x3D; integer + dsep + rem;
            }
        } else {
            str &#x3D; integer;
        }
        return str;
      }

      /**
       * APIProperty: geodesic
       * {Boolean} Use geodesic measurement. Default is false. The recommended
       * setting for maps in EPSG:4326 is false, and true EPSG:900913. If set to
       * true, the scale will be calculated based on the horizontal size of the
       * pixel in the center of the map viewport.
       */
      geodesic:boolean;

      /**
       * Property: maxWidth
       * {Integer} Maximum width of the scale line in pixels.  Default is 100.
       */
      maxWidth;
      
      /**
      * Property: topOutUnits
      * {String} Units for zoomed out on top bar.  Default is km.
      */
      topOutUnits;
      
      /**
        * Property: topInUnits
        * {String} Units for zoomed in on top bar.  Default is m.
        */
      topInUnits;
  
      /**
        * Property: bottomOutUnits
        * {String} Units for zoomed out on bottom bar.  Default is mi.
        */
      bottomOutUnits;
  
      /**
        * Property: bottomInUnits
        * {String} Units for zoomed in on bottom bar.  Default is ft.
        */
      bottomInUnits;

      getBarLen(maxLen):number {
        // nearest power of 10 lower than maxLen
        var digits &#x3D; parseInt((Math.log(maxLen) / Math.log(10)) + &quot;&quot;);
        var pow10 &#x3D; Math.pow(10, digits);
        
        // ok, find first character
        var firstChar &#x3D; parseInt((maxLen / pow10) + &quot;&quot;);

        // right, put it into the correct bracket
        var barLen;
        if(firstChar &gt; 5) {
            barLen &#x3D; 5;
        } else if(firstChar &gt; 2) {
            barLen &#x3D; 2;
        } else {
            barLen &#x3D; 1;
        }

        // scale it up the correct power of 10
        return barLen * pow10;
      }

      /**
       * Method: update
       * Update the size of the bars, and the labels they contain.
       */
      update() {
        var map &#x3D; this.getMap();
        if (!map) {
          return;
        }
        var res &#x3D; map.getView().getResolution();
        if (!res) {
            return;
        }

        var curMapUnits &#x3D; map.getView().getProjection().getUnits();
        var inches &#x3D; PROJECTION_INCHES_PER_UNIT;

        // convert maxWidth to map units
        var maxSizeData &#x3D; this.maxWidth * res * inches[curMapUnits];
        var geodesicRatio &#x3D; 1;
        if(this.geodesic &#x3D;&#x3D;&#x3D; true) {
            var maxSizeGeodesic &#x3D; (this.getGeodesicPixelSize()[0]/*w*/ ||
                0.000001) * this.maxWidth;
            var maxSizeKilometers &#x3D; maxSizeData / inches[&quot;km&quot;];
            geodesicRatio &#x3D; maxSizeGeodesic / maxSizeKilometers;
            maxSizeData *&#x3D; geodesicRatio;
        }

        // decide whether to use large or small scale units     
        var topUnits;
        var bottomUnits;
        if(maxSizeData &gt; 100000) {
            topUnits &#x3D; this.topOutUnits;
            bottomUnits &#x3D; this.bottomOutUnits;
        } else {
            topUnits &#x3D; this.topInUnits;
            bottomUnits &#x3D; this.bottomInUnits;
        }

        // and to map units units
        var topMax &#x3D; maxSizeData / inches[topUnits];
        var bottomMax &#x3D; maxSizeData / inches[bottomUnits];

        // now trim this down to useful block length
        var topRounded &#x3D; this.getBarLen(topMax);
        var bottomRounded &#x3D; this.getBarLen(bottomMax);

        // and back to display units
        topMax &#x3D; topRounded / inches[curMapUnits] * inches[topUnits];
        bottomMax &#x3D; bottomRounded / inches[curMapUnits] * inches[bottomUnits];

        // and to pixel units
        var topPx &#x3D; topMax / res / geodesicRatio;
        var bottomPx &#x3D; bottomMax / res / geodesicRatio;
        
        // now set the pixel widths
        // and the values inside them

        if (this.innerElement_) {
          //Update bar width with top value always
          this.innerElement_.style.width &#x3D; Math.round(topPx) + &quot;px&quot;; 
        }
        
        if (this.eBottom &amp;&amp; this.eBottom.style &amp;&amp; (this.eBottom.style.visibility &#x3D;&#x3D; &quot;visible&quot;)) {
            //Update bottom bar width with its corresponding value
            this.eBottom.style.width &#x3D; Math.round(bottomPx) + &quot;px&quot;; 
            this.eBottom.innerHTML &#x3D; bottomRounded + &quot; &quot; + bottomUnits ;
        }
            
        if (this.eTop &amp;&amp; this.eTop.style &amp;&amp; (this.eTop.style.visibility &#x3D;&#x3D; &quot;visible&quot;)) {
            //this.eTop.style.width &#x3D; Math.round(topPx) + &quot;px&quot;;
            this.eTop.innerHTML &#x3D; topRounded + &quot; &quot; + topUnits;
        }

        if (this.element_) {
          var scale &#x3D; MapComponent.getScaleFromResolution(this.getMap().getView().getResolution(), 
                                                this.getMap().getView().getProjection().getUnits());
          // update the element title and width
          this.element_.title &#x3D; this.tooltipMessage + this.formatNumber(scale);
        }
        
      }

      getGeodesicPixelSize(px?) {
        var map &#x3D; this.getMap();
        var lonlat &#x3D; px ? map.getCoordinateFromPixel(px) : (
          map.getView().getCenter() || [0,0]);
        var res &#x3D; map.getView().getResolution();
        var left &#x3D; ol.coordinate.add(lonlat, [-res / 2, 0]);
        var right &#x3D; ol.coordinate.add(lonlat, [res / 2, 0]);
        var bottom &#x3D; ol.coordinate.add(lonlat, [0, -res / 2]);
        var top &#x3D; ol.coordinate.add(lonlat, [0, res / 2]);
        var dest &#x3D; new ol.proj.Projection({
                        code:&quot;EPSG:4326&quot;
                      });
        var source &#x3D; map.getView().getProjection() || dest;
        if(source.getCode() !&#x3D; dest.getCode()) {
            left &#x3D; ol.proj.transform(left, source, dest);
            right &#x3D; ol.proj.transform(right, source, dest);
            bottom &#x3D; ol.proj.transform(bottom, source, dest);
            top &#x3D; ol.proj.transform(top, source, dest);
        }
        
        return [
            distVincenty(left, right),//w
            distVincenty(bottom, top)//h
            ];
      }

      displayClass;
      showTopBar;
      showBottomBar;
      eTop;
      eBottom;
      draw() {
        if (!this.eTop) {
            if (!this.displayClass) {
              this.displayClass &#x3D; &quot;&quot;;
            }
            // stick in the top bar
            this.eTop &#x3D; document.createElement(&quot;div&quot;);
            this.eTop.className &#x3D; this.displayClass + &quot;Top&quot;;
            var theLen &#x3D; this.topInUnits.length;
            this.element_.appendChild(this.eTop);
            if((this.topOutUnits &#x3D;&#x3D; &quot;&quot;) || (this.topInUnits &#x3D;&#x3D; &quot;&quot;) || !this.showTopBar) {
                this.eTop.style.visibility &#x3D; &quot;hidden&quot;;
            } else {
                this.eTop.style.visibility &#x3D; &quot;visible&quot;;
            }
            this.eTop.style.display &#x3D; this.showTopBar?&quot;&quot;:&quot;none&quot;;

            // and the bottom bar
            this.eBottom &#x3D; document.createElement(&quot;div&quot;);
            this.eBottom.className &#x3D; this.displayClass + &quot;Bottom&quot;;
            this.element_.appendChild(this.eBottom);
            if((this.bottomOutUnits &#x3D;&#x3D; &quot;&quot;) || (this.bottomInUnits &#x3D;&#x3D; &quot;&quot;) || !this.showBottomBar) {
                this.eBottom.style.visibility &#x3D; &quot;hidden&quot;;
            } else {
                this.eBottom.style.visibility &#x3D; &quot;visible&quot;;
            }
            this.eBottom.style.display &#x3D; this.showTopBar?&quot;&quot;:&quot;none&quot;;
        }
      }

    }

    // Auxiliary functions to calculate and register resolution changes
    var VincentyConstants &#x3D; {
      a: 6378137,
      b: 6356752.3142,
      f: 1/298.257223563
    };
    var rad &#x3D; function(x) {return x*Math.PI/180;}
    var distVincenty &#x3D; function(p1, p2) {
      var ct &#x3D; VincentyConstants;
      var a &#x3D; ct.a, b &#x3D; ct.b, f &#x3D; ct.f;
  
      var L &#x3D; rad(p2.lon - p1.lon);
      var U1 &#x3D; Math.atan((1-f) * Math.tan(rad(p1.lat)));
      var U2 &#x3D; Math.atan((1-f) * Math.tan(rad(p2.lat)));
      var sinU1 &#x3D; Math.sin(U1), cosU1 &#x3D; Math.cos(U1);
      var sinU2 &#x3D; Math.sin(U2), cosU2 &#x3D; Math.cos(U2);
      var lambda &#x3D; L, lambdaP &#x3D; 2*Math.PI;
      var iterLimit &#x3D; 20;
      while (Math.abs(lambda-lambdaP) &gt; 1e-12 &amp;&amp; --iterLimit&gt;0) {
          var sinLambda &#x3D; Math.sin(lambda), cosLambda &#x3D; Math.cos(lambda);
          var sinSigma &#x3D; Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) +
          (cosU1*sinU2-sinU1*cosU2*cosLambda) * (cosU1*sinU2-sinU1*cosU2*cosLambda));
          if (sinSigma&#x3D;&#x3D;0) {
              return 0;  // co-incident points
          }
          var cosSigma &#x3D; sinU1*sinU2 + cosU1*cosU2*cosLambda;
          var sigma &#x3D; Math.atan2(sinSigma, cosSigma);
          var alpha &#x3D; Math.asin(cosU1 * cosU2 * sinLambda / sinSigma);
          var cosSqAlpha &#x3D; Math.cos(alpha) * Math.cos(alpha);
          var cos2SigmaM &#x3D; cosSigma - 2*sinU1*sinU2/cosSqAlpha;
          var C &#x3D; f/16*cosSqAlpha*(4+f*(4-3*cosSqAlpha));
          lambdaP &#x3D; lambda;
          lambda &#x3D; L + (1-C) * f * Math.sin(alpha) *
          (sigma + C*sinSigma*(cos2SigmaM+C*cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)));
      }
      if (iterLimit&#x3D;&#x3D;0) {
          return NaN;  // formula failed to converge
      }
      var uSq &#x3D; cosSqAlpha * (a*a - b*b) / (b*b);
      var A &#x3D; 1 + uSq/16384*(4096+uSq*(-768+uSq*(320-175*uSq)));
      var B &#x3D; uSq/1024 * (256+uSq*(-128+uSq*(74-47*uSq)));
      var deltaSigma &#x3D; B*sinSigma*(cos2SigmaM+B/4*(cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-
          B/6*cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));
      var s &#x3D; b*A*(sigma-deltaSigma);
      var d &#x3D; Number.parseFloat(s.toFixed(3))/1000; // round to 1mm precision
      return d;
    };

    const PROJECTION_INCHES_PER_UNIT &#x3D; { 
      &#x27;inches&#x27;: 1.0,
      &#x27;ft&#x27;: 12.0,
      &#x27;mi&#x27;: 63360.0,
      &#x27;m&#x27;: 39.3701,
      &#x27;km&#x27;: 39370.1,
      &#x27;dd&#x27;: 4374754,
      &#x27;yd&#x27;: 36
    };

    /**Custom GetFeatureInfo control*/
    class GetFeatureInfoControl extends ol.control.Control{

      dialog: MatDialog;
      controlDialogRef: MatDialogRef&lt;FeatureInfoDialogComponent&gt;;
      toolContainer;

      button;
      active:boolean;

      layers;
      listener;
      visibleLayers;
      defaultInfoFormat;
      disabled;

      setDialog(dialog: MatDialog) {
        this.dialog &#x3D; dialog;
      }

      onDataChanged(data) {
        //Check if there are queryable layers available
        this.visibleLayers &#x3D; 0;
        var this_ &#x3D; this;
        if (data &amp;&amp; data.layers &amp;&amp; data.layers.length) {
          this.layers &#x3D; data.layers;
          this.showTool();
          //Check if there are queryable layers visible
          data.layers.forEach(function(layer, index, layers){
            if (layer.getVisible()) {
              this_.visibleLayers++;
            }
          });
          if (this.visibleLayers &gt; 0) {
            this.enableTool();
          } else {
            this.disableTool();
          }
        } else {
          this.layers &#x3D; [];
          //hide tool
          this.hideTool();
        }
      }

      updateVisibleLayers(showLayer) {
        this.visibleLayers &#x3D; this.visibleLayers + (showLayer?1:-1);
        if (this.visibleLayers &lt; 0) {
          this.visibleLayers &#x3D; 0;
        }
      }

      showToolDialog(location) {
        if (!location) {
          // No point or area info
          return;
        }
        if ((this.dialog !&#x3D; null) &amp;&amp; (this.dialog !&#x3D; undefined)) {
          const dialogConfig &#x3D; new MatDialogConfig();

          dialogConfig.disableClose &#x3D; true;
          dialogConfig.autoFocus &#x3D; true;
          dialogConfig.hasBackdrop &#x3D; true;

          var data &#x3D; new FeatureInfoDialogData();

          data.requests &#x3D; this.getQueryRequests(location);

          dialogConfig.data &#x3D; data;

          var this_ &#x3D; this;

          this.controlDialogRef &#x3D; this.dialog.open(FeatureInfoDialogComponent, dialogConfig);
          this.controlDialogRef.afterClosed().subscribe(
            data &#x3D;&gt; {
                try {
                  // Do something??
                } catch (e) {
                  //
                }
            }
          );
        }
      }
      
      createGetFeatureInfoUrl(layer:ol.layer.Layer, location) {
        //Example
        //http://sitmun.diba.cat/arcgis/services/PUBLIC/DTE50/MapServer/WMSServer?SERVICE&#x3D;WMS&amp;REQUEST&#x3D;GetFeatureInfo&amp;LAYERS&#x3D;DTE50_MUN&amp;QUERY_LAYERS&#x3D;DTE50_MUN&amp;EXCEPTIONS&#x3D;INIMAGE&amp;VERSION&#x3D;1.3.0&amp;TRANSPARENT&#x3D;true&amp;FORMAT&#x3D;image/png8&amp;STYLES&#x3D;&amp;CRS&#x3D;EPSG:25831&amp;INFO_FORMAT&#x3D;text/xml&amp;WIDTH&#x3D;1355&amp;HEIGHT&#x3D;753&amp;BBOX&#x3D;297073.421925,4554115.600155,548030.578075,4693577.399845&amp;I&#x3D;438&amp;J&#x3D;286
        var source &#x3D; layer.getSource();
        var params &#x3D; {};
        var format &#x3D; layer.getProperties()[&quot;infoFormat&quot;];
        params[&quot;INFO_FORMAT&quot;] &#x3D; format?format:this.defaultInfoFormat;
        if (source instanceof ol.source.TileWMS) {
          var tileWmsSource:ol.source.TileWMS &#x3D; source;
          return tileWmsSource.getGetFeatureInfoUrl(
            location, 
            this.getMap().getView().getResolution(),
            this.getMap().getView().getProjection(),
            params
          );
        } else if (source instanceof ol.source.ImageWMS) {
          var imageWmsSource:ol.source.ImageWMS &#x3D; source;
          return imageWmsSource.getGetFeatureInfoUrl(
            location, 
            this.getMap().getView().getResolution(),
            this.getMap().getView().getProjection(),
            params);
        }
		    return null;
      }
      
      getQueryRequests(location):Array&lt;FeatureInfoRequestData&gt; {
        var requests &#x3D; new Array&lt;FeatureInfoRequestData&gt;();
        //Crear peticiones get feature info para cada capa visible
        var this_ &#x3D; this;
        this.layers.forEach(function(layer, index, layers) {
          if (layer.getVisible()) {
            var url &#x3D; this_.createGetFeatureInfoUrl(layer, location);
            if (url) {
              var request &#x3D; new FeatureInfoRequestData();
              request.title &#x3D; layer.getProperties()[&quot;title&quot;];
              request.request &#x3D; url;
              var format &#x3D; layer.getProperties()[&quot;infoFormat&quot;];
              request.type &#x3D; format?format:this_.defaultInfoFormat;
              requests.push(request);
            }
          }
        });
        return requests;
      }

      toggleActivate() {
        if (!this.disabled) {
          if (!this.active) {
            this.activate()
          } else {
            this.deactivate();
          };
        }
      }
      
      activate() {
        if (this.disabled) {
          return;
        }
        if (!this.active) {
          if (this.button) {
            if (this.button.className.indexOf(&quot; tool-active&quot;) &#x3D;&#x3D; -1) {
              this.button.className +&#x3D; &quot; tool-active&quot;;
            }
          }
          this.active &#x3D; true;
          //register map clicks
          var this_ &#x3D; this;
          this.listener &#x3D; function(evt:ol.MapBrowserEvent) {
            this_.showToolDialog(this_.getMap().getCoordinateFromPixel(evt.pixel));
          };
          this.getMap().on(&quot;click&quot;, this.listener);
        }
      }
      
      deactivate() {
        if (this.active) {
          if (this.button) {
            if (this.button.className.indexOf(&quot; tool-active&quot;) !&#x3D; -1) {
              this.button.className &#x3D; this.button.className.replace(&quot; tool-active&quot;, &quot;&quot;);
            }
          }
          this.active &#x3D; false;
          //unregister map clicks
          if (this.listener) {
            this.getMap().un(&quot;click&quot;, this.listener);
          }
          this.listener &#x3D; null;
        }
      }

      constructor(opt_options) {  
        var options &#x3D; opt_options || {};

        var element &#x3D; document.createElement(&quot;DIV&quot;);
        element.className &#x3D; &quot;ol-get-feature-info ol-unselectable ol-control&quot;
        //initially hidden
        element.style.display &#x3D; &quot;none&quot;;
        element.style.visibility &#x3D; &quot;hidden&quot;;

        super({
          element: element,
          target: options.target
        });

        if (options.defaultInfoFormat) {
          this.defaultInfoFormat &#x3D; options.defaultInfoFormat;
        } else {
          this.defaultInfoFormat &#x3D; &quot;text/xml&quot;;
        }

        var this_ &#x3D; this;

        var controlBtn &#x3D; document.createElement(&quot;BUTTON&quot;); 
        if ((options.tooltip !&#x3D; null) &amp;&amp; (options.tooltip !&#x3D; null)) {
          controlBtn.title &#x3D; options.tooltip;
        }

        controlBtn.setAttribute(&quot;type&quot;, &quot;button&quot;);
        controlBtn.id&#x3D;&quot;get-feature-info-btn&quot;;
        controlBtn.className &#x3D; &quot;mat-raised-button&quot;;
        var icon &#x3D; document.createElement(&#x27;i&#x27;);
        icon.className&#x3D;&quot;material-icons&quot;;
        icon.innerHTML&#x3D;&quot;perm_device_information&quot;;
        controlBtn.appendChild(icon);
        element.appendChild(controlBtn);

        if (isEventSupported(&#x27;touchstart&#x27;)) {
          controlBtn.addEventListener(&#x27;touchstart&#x27;, function() {
                this_.toggleActivate();
            }, false);
        } else {
            controlBtn.addEventListener(&#x27;click&#x27;, function() {
                this_.toggleActivate();
            }, false);
        }

        this.button &#x3D; controlBtn;

        this.toolContainer &#x3D; element;            

        this.onDataChanged({
          layers: options.layers
        });
      }
      
      enableTool() {
        this.disabled &#x3D; false;
        if (this.button) {
          if (this.button.className.indexOf(&quot; tool-disabled&quot;) !&#x3D; -1) {
            this.button.className &#x3D; this.button.className.replace(&quot; tool-disabled&quot;, &quot;&quot;);
          }
        }
      }
      
      disableTool() {
        this.disabled &#x3D; true;
		    this.deactivate();
        if (this.button) {
          if (this.button.className.indexOf(&quot; tool-disabled&quot;) &#x3D;&#x3D; -1) {
            this.button.className &#x3D; this.button.className +&#x3D; &quot; tool-disabled&quot;;
          }
        }
      }

      hideTool() {
		    this.deactivate();
        if (this.toolContainer) {
          this.toolContainer.style.display &#x3D; &quot;none&quot;;
          this.toolContainer.style.visibility &#x3D; &quot;hidden&quot;;
          //TODO Notify control hidden
        }
      }

      showTool() {
        if (this.toolContainer) {
          this.toolContainer.style.display &#x3D; &quot;&quot;;
          this.toolContainer.style.visibility &#x3D; &quot;visible&quot;;          
          //TODO Notify control shown
        }
      }

      updateTooltip(tooltip) {
        if (this.button) {
          this.button.title &#x3D; tooltip;
        }
      }
    }

    ///////////////////////
    // Map configuration //
    ///////////////////////

    var attributionsLabel &#x3D; document.createElement(&quot;I&quot;);
    attributionsLabel.className &#x3D; &quot;material-icons&quot;;
    attributionsLabel.innerHTML &#x3D; &quot;info&quot;;
    var attributionsCollapseLabel &#x3D; document.createElement(&quot;I&quot;);
    attributionsCollapseLabel.className &#x3D; &quot;material-icons&quot;;
    attributionsCollapseLabel.innerHTML &#x3D; &quot;keyboard_arrow_right&quot;;

    this.attributionToolControl &#x3D; new ol.control.Attribution({
      collapsible: true,
      tipLabel: this.messages[&quot;attributionsTooltip&quot;],
      collapseLabel: attributionsCollapseLabel,
      label:attributionsLabel
    });

    this.zoomToolControl &#x3D; new ol.control.Zoom({
      zoomInTipLabel: this.messages[&quot;zoomInTooltip&quot;],
      zoomOutTipLabel: this.messages[&quot;zoomOutTooltip&quot;]
    });

    var layers &#x3D; [];
    if (this.baseLayers) {
      layers &#x3D; layers.concat(this.baseLayers);
    }
    if (this.layers) {
      layers &#x3D; layers.concat(this.layers)
    }
    var viewOptions &#x3D; {
      projection: new ol.proj.Projection({
        code: this.projection,
        units: this.units
      })
    };
    if (this.maxExtent) {
      viewOptions[&quot;extent&quot;] &#x3D; this.maxExtent;
    }
    if (this.resolutions) {

      viewOptions[&quot;resolutions&quot;] &#x3D; this.resolutions;
    }
    if (initialCenter) {

      viewOptions[&quot;center&quot;] &#x3D; initialCenter;
    }
    if ((initialZoom !&#x3D; null) &amp;&amp; (initialZoom !&#x3D; undefined)) {
      viewOptions[&quot;zoom&quot;] &#x3D; initialZoom;
    }
    this.map &#x3D; new ol.Map({
      target: &#x27;map&#x27;,
      layers: layers,
      // Configure default controls
      controls: ol.control.defaults({attribution: false, zoom:false, rotate:false}).extend([this.attributionToolControl, this.zoomToolControl]),
      view: new ol.View(viewOptions)
    });

    //Update attribution button to apply a material style
    var attributionNodeList &#x3D; document.getElementsByClassName(&quot;ol-attribution&quot;);
    if ((attributionNodeList !&#x3D; null) &amp;&amp; (attributionNodeList !&#x3D; undefined) &amp;&amp; (attributionNodeList.length &gt; 0)) {
      var buttonList &#x3D; attributionNodeList[0].getElementsByTagName(&quot;BUTTON&quot;);
      if ((buttonList !&#x3D; null) &amp;&amp; (buttonList !&#x3D; undefined)) {
        for (var i &#x3D; 0, iLen &#x3D; buttonList.length; i &lt; iLen; i++) {
          buttonList[i].className +&#x3D; &quot; mat-raised-button ol-attribution-btn&quot;;
        }
      }
    }


    if ((this._extent !&#x3D; null) &amp;&amp; (this._extent !&#x3D; undefined)) {
      this.setExtent(this._extent);
    }

    var zoomInBtnList &#x3D; document.getElementsByClassName(&quot;ol-zoom-in&quot;);
    if ((zoomInBtnList !&#x3D; null) &amp;&amp; (zoomInBtnList.length &gt; 0)) {
      zoomInBtnList[0].className +&#x3D; &quot; mat-raised-button&quot;;
    }
    var zoomOutBtnList &#x3D; document.getElementsByClassName(&quot;ol-zoom-out&quot;);
    if ((zoomOutBtnList !&#x3D; null) &amp;&amp; (zoomOutBtnList.length &gt; 0)) {
      zoomOutBtnList[0].className +&#x3D; &quot; mat-raised-button&quot;;
    }

    //////////////////////////////////
    // Custom control instantiation //
    //////////////////////////////////

    // Scale line control
    this.scaleLineToolControl &#x3D; 
                            new ScaleBarControl({
                              showTopBar: true,//metric
                              showBottomBar: false,//non-metric
                              tooltipMessage: this.messages[&quot;scaleLineTooltip&quot;]
                            });

    this.map.addControl(this.scaleLineToolControl);
    var scaleLineElementContainerList &#x3D; document.getElementsByClassName(&quot;ol-scale-line&quot;);

    this.locationToolControl &#x3D; new GeolocationControl({
      geolocationTooltip: this.messages[&quot;geolocationTooltip&quot;]
    });
    // Geolocation control
    this.map.addControl(this.locationToolControl);

    // Create the base layer selection control it will remain hidden until
    // more than one base layer group has been defined
    // Base layer selection control
    this.selectBaseLayerControl &#x3D; new SelectBaseLayerControl({
      layerGroups: this.baseLayerGroups,
      layers: this.baseLayers,
      tooltip: this.messages[&quot;layerSelectionTooltip&quot;]
    });
    this.selectBaseLayerControl.setDialog(this.dialog);
    this.map.addControl(this.selectBaseLayerControl);

    // Base layer selection control
    this.getFeatureInfoControl &#x3D; new GetFeatureInfoControl({
      layers: this.getQueryableLayers(),
      tooltip: this.messages[&quot;getFeatureInfoTooltip&quot;],
      defaultInfoFormat: this.defaultMapInfoFormat
    });
    this.getFeatureInfoControl.setDialog(this.featureInfoDialog);
    this.map.addControl(this.getFeatureInfoControl);

    this.loadingControl &#x3D; new LoadingControl({
      progress: false
    });
    this.map.addControl(this.loadingControl);

    //OverView Map Code
    var overViewNode &#x3D; document.createElement(&#x27;I&#x27;);
    overViewNode.className &#x3D; &quot;material-icons&quot;;
    overViewNode.innerHTML &#x3D; &quot;map&quot;;
    var overViewNodeCollapsed &#x3D; document.createElement(&#x27;I&#x27;);
    overViewNodeCollapsed.className &#x3D; &quot;material-icons&quot;;
    overViewNodeCollapsed.innerHTML &#x3D; &quot;keyboard_arrow_left&quot;;

    this.overViewMapControl &#x3D; new ol.control.OverviewMap({
      label: overViewNode,
      collapseLabel: overViewNodeCollapsed,
      tipLabel: this.messages[&quot;overviewTooltip&quot;],
      layers: [new ol.layer.Vector()],//Add a layer to avoid copying the current map configuration
      view: new ol.View({//Configure the overview map view similar to the map&#x27;s view
        projection: new ol.proj.Projection({
          code: this.map.getView().getProjection().getCode(),
          units: this.map.getView().getProjection().getUnits()
        }),
        resolutions: this.map.getView().getResolutions(),
        center: this.map.getView().getCenter(),
        zoom: this.map.getView().getZoom(),
        extent: this.maxExtent
      })
    });
    this.map.addControl(this.overViewMapControl);

    //Update attribution button to apply a material style
    var overviewNodeList &#x3D; document.getElementsByClassName(&quot;ol-overviewmap&quot;);
    if ((overviewNodeList !&#x3D; null) &amp;&amp; (overviewNodeList !&#x3D; undefined) &amp;&amp; (overviewNodeList.length &gt; 0)) {
      var buttonList &#x3D; overviewNodeList[0].getElementsByTagName(&quot;BUTTON&quot;);
      if ((buttonList !&#x3D; null) &amp;&amp; (buttonList !&#x3D; undefined)) {
        for (var i &#x3D; 0, iLen &#x3D; buttonList.length; i &lt; iLen; i++) {
          buttonList[i].className +&#x3D; &quot; mat-raised-button ol-overviewmap-btn&quot;;
        }
      }
    }

    //Measurement control
    this.measurementToolControl &#x3D; new MeasurementControl({
      lengthTooltip: this.messages[&quot;lengthTooltip&quot;],
      areaTooltip: this.messages[&quot;areaTooltip&quot;],
      continueLineMsg: this.messages[&quot;continueLineMsg&quot;],
      continuePolygonMsg:  this.messages[&quot;continuePolygonMsg&quot;],
      strokeFinishedColorStyle: measurementStrokeFinishedColorStyle,
      strokeMeasuringColorStyle: measurementStrokeMeasuringColorStyle,
      strokeImageMeasuringColorStyle: measurementStrokeImageMeasuringColorStyle,
      backgroundColorStyle: measurementBackgroundColorStyle,
      drawHelpTooltip: false
    });
    this.map.addControl(this.measurementToolControl);

    //Register to receive map data updates
    this.initializeMapConfigurationManager();

    // Load default values
    if (this._loadDefaults) {
      this.loadDefaultMapConfiguration();
    }

    var mapStatus &#x3D; new MapComponentStatus();
    mapStatus.loaded &#x3D; true;
    //Notify the map has been initialized and is ready 
    this.mapConfigurationManagerService.setMapComponentStatus(mapStatus);
  }

  /** normalize to given scale*/
  public static normalizeScale(scale) {
    var normScale&#x3D;(scale&gt;1.0)?(1.0/scale):scale;
    return normScale;
  }
  
  /** get scale from given resolution*/
  public static getScaleFromResolution(resolution, units?) {
    units &#x3D; units?units:&quot;m&quot;;
    var dpi &#x3D; 25.4 / 0.28;
    var mpu &#x3D; ol.proj.METERS_PER_UNIT[units];
    var inchesPerMeter &#x3D; 39.37;
    return (resolution * (mpu * inchesPerMeter * dpi));
  }
  
  /** get resolution from given scale*/
  public static getResolutionFromScale(scale, units?) {
    units &#x3D; units?units:&quot;m&quot;;
    var normScale &#x3D; MapComponent.normalizeScale(scale);
    var dpi &#x3D; 25.4 / 0.28;
    var mpu &#x3D; ol.proj.METERS_PER_UNIT[units];
    var inchesPerMeter &#x3D; 39.37;
    return (1 /(normScale * (mpu * inchesPerMeter * dpi)));
  }

  /** defaults loaded?*/
  defaultsLoaded:boolean &#x3D; false;
  
  /** load default map configuration*/
  loadDefaultMapConfiguration() {
    //Load default configuration
    //Projection, escales, extent
    if (this.getMap() !&#x3D; null) {
      if (!this.defaultsLoaded) {
        this.defaultsLoaded &#x3D; true;
        this.updateMapOptions(this.getDefaultMapOptionsConfiguration());
        this.configureBaseLayers(this.getDefaultBaseLayersConfiguration());
      }
    }
  }

  /** default initial zoom*/
  defaultInitialZoom &#x3D; 0;
  
  /** setdefault initial zoom*/
  setDefaultInitialZoom(zoom) {
    this.defaultInitialZoom &#x3D; zoom;
  }
  
  /** get default initial zoom*/
  getDefaultInitialZoom():number {
    return this.defaultInitialZoom;
  }

  /** default initial lon*/
  defaultInitialLon &#x3D; 405808.5;
  
  /** set default initial lon*/
  setDefaultInitialLon(lon) {
    this.defaultInitialLon &#x3D; lon;
  }
  
  /** get default initial lon*/
  getDefaultInitialLon():number {
    return this.defaultInitialLon;
  }
  
  /** default initial lat*/
  defaultInitialLat &#x3D; 4623846.5;
  
  /** set default initial lat*/
  setDefaultInitialLat(lat) {
    this.defaultInitialLat &#x3D; lat;
  }
  
  /** get default initial lat*/
  getDefaultInitialLat():number {
    return this.defaultInitialLat;
  }
  
  /** default tile height*/
  defaultTileHeight &#x3D; 500;
  
  /** set default tile height*/
  setDefaultTileHeight(height) {
    this.defaultTileHeight &#x3D; height;
  }
  
  /** get default tile height*/
  getDefaultTileHeight():number {
    return this.defaultTileHeight;
  }
  
  /** set default tile width*/
  defaultTileWidth &#x3D; 500;
  
  /** set default tile width*/
  setDefaultTileWidth(width) {
    this.defaultTileWidth &#x3D; width;
  }
  
  /** get default tile width*/
  getDefaultTileWidth():number {
    return this.defaultTileWidth;
  }
  
  /** default map max scale*/
  defaultMapMaxScale &#x3D; 3000000;
  
  /** set default map max scale*/
  setDefaultMapMaxScale(scale) {
    this.defaultMapMaxScale &#x3D; scale;
  }
  
  /** get default map max scale*/
  getDefaultMapMaxScale():number {
    return this.defaultMapMaxScale;
  }
  
  /** default map min scale*/
  defaultMapMinScale &#x3D; 3000;
  
  /** set default map min scale*/
  setDefaultMapMinScale(scale) {
    this.defaultMapMinScale &#x3D; scale;
  }
  
  /** get default map min scale*/
  getDefaultMapMinScale():number {
    return this.defaultMapMinScale;
  }
  
  /** default map maximum extent*/
  defaultMapMaxExtent:[number, number, number, number] &#x3D; [
    320000, //xMin
    4561229,//yMin
    491617, //xMax
    4686464 //yMax
  ];
  
  /** set default map maximum extent*/
  setDefaultMapMaxExtent(extent) {
    this.defaultMapMaxExtent &#x3D; extent;
  }
  
  /** get default map maximum extent*/
  getDefaultMapMaxExtent():[number, number, number, number] {
    return this.defaultMapMaxExtent;
  }

  /** default map resolutions*/
  defaultMapResolutions &#x3D; [
    264.5831904584105,
    ​185.20823332088733,
    ​132.29159522920526,
    ​105.83327618336418,
    ​79.37495713752315,
    ​52.91663809168209,
    ​26.458319045841044,
    ​13.229159522920522,
    ​6.614579761460261,
    ​5.2916638091682096,
    ​2.6458319045841048,
    ​1.3231805354825108,
    ​0.6614579761460262,
    ​0.2645831904584105,
    ​0.1322915952292052
  ];
  
  /** set default map resolutions*/
  setDefaultMapResolutions(resolutions) {
    this.defaultMapResolutions &#x3D; resolutions;
  }
  
  /** get default map resolutions*/
  getDefaultMapResolutions() {
    return this.defaultMapResolutions;
  }

  /** default map scales*/
  defaultMapScales &#x3D; [
    1000000,
    700000,
    ​500000,
    400000,
    300000,
    200000,
    100000,
    50000,
    25000,
    20000,
    10000,
    5001,
    2500,
    1000,
    500
  ];
  
  /** set default map scales*/
  setDefaultMapScales(scales) {
    this.defaultMapScales &#x3D; scales;
  }
  
  /** get default map scales*/
  getDefaultMapScales() {
    return this.defaultMapScales;
  }
  
  /** default map info format*/
  defaultMapInfoFormat:string &#x3D; &quot;text/xml&quot;;
  setDefaultMapInfoFormat(format:string) {
    this.defaultMapInfoFormat &#x3D; format;
  }
  
  /** get default map info format*/
  getDefaultMapInfoFormat():string {
    return this.defaultMapInfoFormat;
  }

  
  /** get default map configuration*/
  getDefaultMapConfiguration() {
    var configuration &#x3D; new MapConfiguration();
    configuration.initialZoom &#x3D; this.getDefaultInitialZoom();
    configuration.initialLon &#x3D; this.getDefaultInitialLon();
    configuration.initialLat &#x3D; this.getDefaultInitialLat();
    configuration.initialProjection &#x3D; this.getDefaultProjection();
    configuration.tileHeight &#x3D; this.getDefaultTileHeight();
    configuration.tileWidth &#x3D; this.getDefaultTileWidth();
    configuration.mapProjection &#x3D; this.getDefaultProjection();
    configuration.mapUnits &#x3D; this.getProjectionUnits(configuration.mapProjection);
    /*
    configuration.mapMaxScale &#x3D; this.getDefaultMapMaxScale();
    configuration.mapMinScale &#x3D; this.getDefaultMapMinScale();
    configuration.mapMaxExtent &#x3D; this.getDefaultMapMaxExtent();
    configuration.mapResolutions &#x3D; this.getDefaultMapResolutions();
    */
    return configuration;   
  }
  
  /** get default map options configuration*/
  getDefaultMapOptionsConfiguration() {
    var configuration &#x3D; new MapOptionsConfiguration();
    //configuration.extent &#x3D; [this.getDefaultInitialLon(), this.getDefaultInitialLat()];
    configuration.tileHeight &#x3D; this.getDefaultTileHeight();
    configuration.tileWidth &#x3D; this.getDefaultTileWidth();
    configuration.projections &#x3D; this.getDefaultProjection();
    configuration.maxScale &#x3D; this.getDefaultMapMaxScale();
    configuration.minScale &#x3D; this.getDefaultMapMinScale();
    configuration.maxExtent &#x3D; this.getDefaultMapMaxExtent();
    configuration.scales &#x3D; this.getDefaultMapScales().join(&quot;,&quot;);
    return configuration;   
  }
  
  /** get default base layers configuration*/
  getDefaultBaseLayersConfiguration() {
    var baseLayers &#x3D; new Array&lt;LayerGroup&gt;();

    var layerGroup &#x3D; new LayerGroup();
    layerGroup.id &#x3D; &quot;map&quot;;
    layerGroup.name &#x3D; &quot;Mapa&quot;;
    layerGroup.layers &#x3D; [];

    var layer &#x3D; new Layer();
    layer[&quot;visibility&quot;] &#x3D; false;
    layer[&quot;queryable&quot;] &#x3D; false;
    layer[&quot;opacity&quot;] &#x3D; 1;
    layer[&quot;attributions&quot;] &#x3D; &quot;© Institut Cartogràfíc i Geològic de Catalunya&quot;;
    layer[&quot;desc&quot;] &#x3D; &quot;&quot;;
    layer[&quot;url_transparent&quot;] &#x3D; &quot;TRUE&quot;;
    layer[&quot;url_bgcolor&quot;] &#x3D; &quot;0x000000&quot;;
    layer[&quot;extent&quot;] &#x3D; null;
    layer[&quot;title&quot;] &#x3D; &quot;Base Mapa - imgmapa&quot;;
    layer[&quot;serverName&quot;] &#x3D; &quot;226-212-210-245&quot;; 
    layer[&quot;id&quot;] &#x3D; &quot;226-212-210-245&quot;; 
    layer[&quot;format&quot;] &#x3D; &quot;png&quot;; 
    layer[&quot;version&quot;] &#x3D; &quot;1.1.1&quot;; 
    layer[&quot;url&quot;] &#x3D; &quot;http://sitmun.diba.cat/arcgis/services/PUBLIC/GCA_WEB/MapServer/WMSServer&quot;; 
    layer[&quot;isBaseLayer&quot;] &#x3D; false;
    layer[&quot;name&quot;] &#x3D; &quot;M_PROV_FONS,M_EURB_250M,M_EDIF_1M_141A,M_BTE50_412A,M_EDIF_1M_611A,M_XHE50_111L,M_BTE50_313L_FFCC,M_EIX,M_EIX_sobre_EDIF,M_XCE50_AUTO,M_XCE50_BASICA,M_XCE50_LOCAL,M_XCE50_ALTRES,M_XCE50_AUTO_f,M_XCE50_BASICA_f,M_XCE50_LOCAL_f,M_XCE50_ALTRES_f,M_MUNIS_f,M_MUNIS&quot;;
    layer[&quot;tiled&quot;] &#x3D; false;
    layerGroup.layers.push(layer);

    layer &#x3D; new Layer();
    layer[&quot;visibility&quot;] &#x3D; false;
    layer[&quot;queryable&quot;] &#x3D; false;
    layer[&quot;opacity&quot;] &#x3D; 1;
    layer[&quot;attributions&quot;] &#x3D; &quot;© Institut Cartogràfíc i Geològic de Catalunya&quot;; 
    layer[&quot;desc&quot;] &#x3D; &quot;&quot;; 
    layer[&quot;url_transparent&quot;] &#x3D; &quot;TRUE&quot;; 
    layer[&quot;url_bgcolor&quot;] &#x3D; &quot;0x000000&quot;; 
    layer[&quot;extent&quot;] &#x3D; null;
    layer[&quot;title&quot;] &#x3D; &quot;Base Mapa - imgmapa_et&quot;; 
    layer[&quot;serverName&quot;] &#x3D; &quot;226-212-210-238&quot;; 
    layer[&quot;id&quot;] &#x3D; &quot;226-212-210-238&quot;; 
    layer[&quot;format&quot;] &#x3D; &quot;png&quot;; 
    layer[&quot;version&quot;] &#x3D; &quot;1.1.1&quot;; 
    layer[&quot;url&quot;] &#x3D; &quot;http://sitmun.diba.cat/arcgis/services/PUBLIC/GCA_WEB/MapServer/WMSServer&quot;; 
    layer[&quot;isBaseLayer&quot;] &#x3D; false;
    layer[&quot;name&quot;] &#x3D; &quot;M_MUNIS&quot;; 
    layer[&quot;tiled&quot;] &#x3D; false;
    layerGroup.layers.push(layer);
    
    layer &#x3D; new Layer();
    layer[&quot;visibility&quot;] &#x3D; false;
    layer[&quot;queryable&quot;] &#x3D; false;
    layer[&quot;opacity&quot;] &#x3D; 1;
    layer[&quot;attributions&quot;] &#x3D; &quot;© Institut Cartogràfíc i Geològic de Catalunya&quot;; 
    layer[&quot;desc&quot;] &#x3D; &quot;&quot;; 
    layer[&quot;url_transparent&quot;] &#x3D; &quot;TRUE&quot;; 
    layer[&quot;url_bgcolor&quot;] &#x3D; &quot;0x000000&quot;; 
    layer[&quot;extent&quot;] &#x3D; null;
    layer[&quot;title&quot;] &#x3D; &quot;Base Mapa - imgeix&quot;; 
    layer[&quot;serverName&quot;] &#x3D; &quot;226-212-210-247&quot;; 
    layer[&quot;id&quot;] &#x3D; &quot;226-212-210-247&quot;; 
    layer[&quot;format&quot;] &#x3D; &quot;png&quot;; 
    layer[&quot;version&quot;] &#x3D; &quot;1.1.1&quot;; 
    layer[&quot;url&quot;] &#x3D; &quot;http://sitmun.diba.cat/arcgis/services/PUBLIC/GCA_WEB/MapServer/WMSServer&quot;; 
    layer[&quot;isBaseLayer&quot;] &#x3D; false;
    layer[&quot;name&quot;] &#x3D; &quot;M_EIX_ET,M_EDI_ET,M_MUNIS_ET&quot;; 
    layer[&quot;tiled&quot;] &#x3D; false;
    layerGroup.layers.push(layer);

    baseLayers.push(layerGroup);

    layerGroup &#x3D; new LayerGroup();
    layerGroup.id &#x3D; &quot;aerial&quot;;
    layerGroup.name &#x3D; &quot;Aerèa&quot;;
    layerGroup.layers &#x3D; [];

    layer &#x3D; new Layer();
    layer[&quot;visibility&quot;] &#x3D; false;
    layer[&quot;queryable&quot;] &#x3D; false;
    layer[&quot;opacity&quot;] &#x3D; 1;
    layer[&quot;attributions&quot;] &#x3D; &quot;© Institut Cartogràfíc i Geològic de Catalunya&quot;; 
    layer[&quot;desc&quot;] &#x3D; &quot;&quot;; 
    layer[&quot;url_transparent&quot;] &#x3D; &quot;TRUE&quot;; 
    layer[&quot;url_bgcolor&quot;] &#x3D; &quot;0x000000&quot;; 
    layer[&quot;extent&quot;] &#x3D; [254904.96, 4484796.89, 530907.3, 4749795.1];
    layer[&quot;title&quot;] &#x3D; &quot;Base Aerial - ICC1&quot;; 
    layer[&quot;serverName&quot;] &#x3D; &quot;272-266-258-252&quot;; 
    layer[&quot;id&quot;] &#x3D; &quot;272-266-258-252&quot;; 
    layer[&quot;format&quot;] &#x3D; &quot;image/png&quot;; 
    layer[&quot;version&quot;] &#x3D; &quot;1.1.1&quot;; 
    layer[&quot;url&quot;] &#x3D; &quot;http://mapcache.icc.cat/map/bases/service&quot;; 
    layer[&quot;isBaseLayer&quot;] &#x3D; false;
    layer[&quot;name&quot;] &#x3D; &quot;orto&quot;; 
    layer[&quot;tiled&quot;] &#x3D; true;
    layer[&quot;tileHeight&quot;] &#x3D; 256; 
    layer[&quot;tileWidth&quot;] &#x3D; 256;
    layerGroup.layers.push(layer);

    layer &#x3D; new Layer();
    layer[&quot;visibility&quot;] &#x3D; false;
    layer[&quot;queryable&quot;] &#x3D; false;
    layer[&quot;opacity&quot;] &#x3D; 0.7;
    layer[&quot;attributions&quot;] &#x3D; &quot;© Institut Cartogràfíc i Geològic de Catalunya&quot;; 
    layer[&quot;desc&quot;] &#x3D; &quot;&quot;; 
    layer[&quot;url_transparent&quot;] &#x3D; &quot;TRUE&quot;; 
    layer[&quot;url_bgcolor&quot;] &#x3D; &quot;0xFEFEFE&quot;; 
    layer[&quot;extent&quot;] &#x3D; null;
    layer[&quot;title&quot;] &#x3D; &quot;Base Aerial - imgaeria_fons&quot;; 
    layer[&quot;serverName&quot;] &#x3D; &quot;272-266-258-256&quot;; 
    layer[&quot;id&quot;] &#x3D; &quot;272-266-258-256&quot;; 
    layer[&quot;format&quot;] &#x3D; &quot;image/png&quot;; 
    layer[&quot;version&quot;] &#x3D; &quot;1.1.1&quot;; 
    layer[&quot;url&quot;] &#x3D; &quot;http://sitmun.diba.cat/arcgis/services/PUBLIC/GCA_WEB/MapServer/WMSServer&quot;; 
    layer[&quot;isBaseLayer&quot;] &#x3D; false;
    layer[&quot;name&quot;] &#x3D; &quot;M_PROV_FONS,M_MUNIS&quot;; 
    layer[&quot;tiled&quot;] &#x3D; false;
    layerGroup.layers.push(layer);

    layer &#x3D; new Layer();
    layer[&quot;visibility&quot;] &#x3D; false;
    layer[&quot;queryable&quot;] &#x3D; false;
    layer[&quot;opacity&quot;] &#x3D; 1;
    layer[&quot;attributions&quot;] &#x3D; &quot;© Institut Cartogràfíc i Geològic de Catalunya&quot;; 
    layer[&quot;desc&quot;] &#x3D; &quot;&quot;; 
    layer[&quot;url_transparent&quot;] &#x3D; &quot;TRUE&quot;; 
    layer[&quot;url_bgcolor&quot;] &#x3D; &quot;0x000000&quot;; 
    layer[&quot;extent&quot;] &#x3D; null;
    layer[&quot;title&quot;] &#x3D; &quot;Base Aerial - imgeix&quot;; 
    layer[&quot;serverName&quot;] &#x3D; &quot;272-266-258-281&quot;; 
    layer[&quot;id&quot;] &#x3D; &quot;272-266-258-281&quot;; 
    layer[&quot;format&quot;] &#x3D; &quot;png&quot;; 
    layer[&quot;version&quot;] &#x3D; &quot;1.1.1&quot;; 
    layer[&quot;url&quot;] &#x3D; &quot;http://sitmun.diba.cat/arcgis/services/PUBLIC/GCA_WEB/MapServer/WMSServer&quot;; 
    layer[&quot;isBaseLayer&quot;] &#x3D; false;
    layer[&quot;name&quot;] &#x3D; &quot;M_EIX_ET,M_EDI_ET,M_MUNIS_ET&quot;; 
    layer[&quot;tiled&quot;] &#x3D; false;
    layerGroup.layers.push(layer);

    baseLayers.push(layerGroup);
    
    layerGroup &#x3D; new LayerGroup();
    layerGroup.id &#x3D; &quot;hybrid&quot;;
    layerGroup.name &#x3D; &quot;Hìbrida&quot;;
    layerGroup.layers &#x3D; [];

    layer &#x3D; new Layer();
    layer[&quot;visibility&quot;] &#x3D; false;
    layer[&quot;queryable&quot;] &#x3D; false;
    layer[&quot;opacity&quot;] &#x3D; 1;
    layer[&quot;attributions&quot;] &#x3D; &quot;© Institut Cartogràfíc i Geològic de Catalunya&quot;; 
    layer[&quot;desc&quot;] &#x3D; &quot;&quot;; 
    layer[&quot;url_transparent&quot;] &#x3D; &quot;TRUE&quot;; 
    layer[&quot;url_bgcolor&quot;] &#x3D; &quot;0x000000&quot;; 
    layer[&quot;extent&quot;] &#x3D; [254904.96, 4484796.89, 530907.3, 4749795.1];
    layer[&quot;title&quot;] &#x3D; &quot;Base Aerial - ICC2&quot;; 
    layer[&quot;serverName&quot;] &#x3D; &quot;273-267-265-254&quot;; 
    layer[&quot;id&quot;] &#x3D; &quot;273-267-265-254&quot;; 
    layer[&quot;format&quot;] &#x3D; &quot;image/png&quot;; 
    layer[&quot;version&quot;] &#x3D; &quot;1.1.1&quot;; 
    layer[&quot;url&quot;] &#x3D; &quot;http://mapcache.icc.cat/map/bases/service&quot;; 
    layer[&quot;isBaseLayer&quot;] &#x3D; false;
    layer[&quot;name&quot;] &#x3D; &quot;orto&quot;; 
    layer[&quot;tiled&quot;] &#x3D; true;
    layer[&quot;tileHeight&quot;] &#x3D; 256; 
    layer[&quot;tileWidth&quot;] &#x3D; 256;
    layerGroup.layers.push(layer);

    layer &#x3D; new Layer();
    layer[&quot;visibility&quot;] &#x3D; false;
    layer[&quot;queryable&quot;] &#x3D; false;
    layer[&quot;opacity&quot;] &#x3D; 0.7;
    layer[&quot;attributions&quot;] &#x3D; &quot;© Institut Cartogràfíc i Geològic de Catalunya&quot;; 
    layer[&quot;desc&quot;] &#x3D; &quot;&quot;; 
    layer[&quot;url_transparent&quot;] &#x3D; &quot;TRUE&quot;; 
    layer[&quot;url_bgcolor&quot;] &#x3D; &quot;0xFEFEFE&quot;; 
    layer[&quot;extent&quot;] &#x3D; null;
    layer[&quot;title&quot;] &#x3D; &quot;Base Hybrid - imghibrid_fons&quot;; 
    layer[&quot;serverName&quot;] &#x3D; &quot;273-267-265-259&quot;; 
    layer[&quot;id&quot;] &#x3D; &quot;273-267-265-259&quot;; 
    layer[&quot;format&quot;] &#x3D; &quot;image/png&quot;; 
    layer[&quot;version&quot;] &#x3D; &quot;1.1.1&quot;; 
    layer[&quot;url&quot;] &#x3D; &quot;http://sitmun.diba.cat/arcgis/services/PUBLIC/GCA_WEB/MapServer/WMSServer&quot;; 
    layer[&quot;isBaseLayer&quot;] &#x3D; false;
    layer[&quot;name&quot;] &#x3D; &quot;M_PROV_FONS,M_EURB_250M,M_EDIF_1M_141A,M_EDIF_1M_611A,M_EIX,M_EIX_sobre_EDIF&quot;;
    layer[&quot;tiled&quot;] &#x3D; false;
    layerGroup.layers.push(layer);

    layer &#x3D; new Layer();
    layer[&quot;visibility&quot;] &#x3D; false;
    layer[&quot;queryable&quot;] &#x3D; false;
    layer[&quot;opacity&quot;] &#x3D; 0.85;
    layer[&quot;attributions&quot;] &#x3D; &quot;© Institut Cartogràfíc i Geològic de Catalunya&quot;; 
    layer[&quot;desc&quot;] &#x3D; &quot;&quot;; 
    layer[&quot;url_transparent&quot;] &#x3D; &quot;TRUE&quot;; 
    layer[&quot;url_bgcolor&quot;] &#x3D; &quot;0x000000&quot;; 
    layer[&quot;extent&quot;] &#x3D; null;
    layer[&quot;title&quot;] &#x3D; &quot;Base Hybrid - imghibrid_ctra&quot;; 
    layer[&quot;serverName&quot;] &#x3D; &quot;273-267-265-261&quot;; 
    layer[&quot;id&quot;] &#x3D; &quot;273-267-265-261&quot;; 
    layer[&quot;format&quot;] &#x3D; &quot;png&quot;; 
    layer[&quot;version&quot;] &#x3D; &quot;1.1.1&quot;; 
    layer[&quot;url&quot;] &#x3D; &quot;http://sitmun.diba.cat/arcgis/services/PUBLIC/GCA_WEB/MapServer/WMSServer&quot;; 
    layer[&quot;isBaseLayer&quot;] &#x3D; false
    layer[&quot;name&quot;] &#x3D; &quot;IH_XCE50_AUTO,IH_XCE50_BASICA,IH_XCE50_LOCAL,IH_XCE50_ALTRES,M_XCE50_AUTO_f,M_XCE50_BASICA_f,M_XCE50_LOCAL_f,M_XCE50_ALTRES_f&quot;;
    layer[&quot;tiled&quot;] &#x3D; false;
    layerGroup.layers.push(layer);

    layer &#x3D; new Layer();
    layer[&quot;visibility&quot;] &#x3D; false;
    layer[&quot;queryable&quot;] &#x3D; false;
    layer[&quot;opacity&quot;] &#x3D; 1;
    layer[&quot;attributions&quot;] &#x3D; &quot;© Institut Cartogràfíc i Geològic de Catalunya&quot;; 
    layer[&quot;desc&quot;] &#x3D; &quot;&quot;; 
    layer[&quot;url_transparent&quot;] &#x3D; &quot;TRUE&quot;; 
    layer[&quot;url_bgcolor&quot;] &#x3D; &quot;0x000000&quot;; 
    layer[&quot;extent&quot;] &#x3D; null;
    layer[&quot;title&quot;] &#x3D; &quot;Base Hybrid - imghibrid_et&quot;; 
    layer[&quot;serverName&quot;] &#x3D; &quot;273-267-265-263&quot;; 
    layer[&quot;id&quot;] &#x3D; &quot;273-267-265-263&quot;; 
    layer[&quot;format&quot;] &#x3D; &quot;png&quot;; 
    layer[&quot;version&quot;] &#x3D; &quot;1.1.1&quot;; 
    layer[&quot;url&quot;] &#x3D; &quot;http://sitmun.diba.cat/arcgis/services/PUBLIC/GCA_WEB/MapServer/WMSServer&quot;; 
    layer[&quot;isBaseLayer&quot;] &#x3D; false;
    layer[&quot;name&quot;] &#x3D; &quot;M_MUNIS&quot;; 
    layer[&quot;tiled&quot;] &#x3D; false;
    layerGroup.layers.push(layer);
    
    baseLayers.push(layerGroup);
    
    return baseLayers;
  }
  
  /** parse given format*/
  parseFormat(format:String) {
    return ((format.indexOf(&quot;image&quot;) &#x3D;&#x3D; -1)?
                &quot;image/&quot;:&quot;&quot;) + 
                format;
  }
}
</code></pre>
    </div>
</div>



                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'class';
            var COMPODOC_CURRENT_PAGE_URL = 'BaseLayerGroup.html';
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
